//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.1.0.0 (NJsonSchema v11.0.2.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const PORTAL_BASE_URL = new InjectionToken<string>('PORTAL_BASE_URL');

export interface IAccountsClient {
  login(loginModel: LoginModel): Observable<TokenModel>;
  logout(logoutModel: LogoutModel): Observable<FileResponse>;
  register(registerModel: RegisterModel): Observable<void>;
  refreshToken(refreshToken: string): Observable<TokenModel>;
  forgotPassword(model: ForgotPasswordModel): Observable<void>;
  recoveryPassword(model: RecoveryPasswordModel): Observable<void>;
  changePassword(model: ChangePasswordModel): Observable<void>;
}

@Injectable({
  providedIn: 'root'
})
export class AccountsClient implements IAccountsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  login(loginModel: LoginModel): Observable<TokenModel> {
    let url_ = this.baseUrl + "/api/accounts/login";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(loginModel);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLogin(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLogin(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<TokenModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<TokenModel>;
    }));
  }

  protected processLogin(response: HttpResponseBase): Observable<TokenModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenModel;
        return _observableOf(result200);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  logout(logoutModel: LogoutModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/accounts/logout";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(logoutModel);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processLogout(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processLogout(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processLogout(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  register(registerModel: RegisterModel): Observable<void> {
    let url_ = this.baseUrl + "/api/accounts/register";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(registerModel);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processRegister(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRegister(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processRegister(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  refreshToken(refreshToken: string): Observable<TokenModel> {
    let url_ = this.baseUrl + "/api/accounts/refresh/{refreshToken}";
    if (refreshToken === undefined || refreshToken === null)
      throw new Error("The parameter 'refreshToken' must be defined.");
    url_ = url_.replace("{refreshToken}", encodeURIComponent("" + refreshToken));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processRefreshToken(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRefreshToken(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<TokenModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<TokenModel>;
    }));
  }

  protected processRefreshToken(response: HttpResponseBase): Observable<TokenModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as TokenModel;
        return _observableOf(result200);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  forgotPassword(model: ForgotPasswordModel): Observable<void> {
    let url_ = this.baseUrl + "/api/accounts/forgot-password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processForgotPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processForgotPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processForgotPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  recoveryPassword(model: RecoveryPasswordModel): Observable<void> {
    let url_ = this.baseUrl + "/api/accounts/recovery-password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processRecoveryPassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRecoveryPassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processRecoveryPassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  changePassword(model: ChangePasswordModel): Observable<void> {
    let url_ = this.baseUrl + "/api/accounts/change-password";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processChangePassword(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processChangePassword(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processChangePassword(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IProfilesClient {
  getProfile(): Observable<ProfileModel>;
  updateProfiles(model: ProfileModel): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class ProfilesClient implements IProfilesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getProfile(): Observable<ProfileModel> {
    let url_ = this.baseUrl + "/api/profiles";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetProfile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetProfile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ProfileModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ProfileModel>;
    }));
  }

  protected processGetProfile(response: HttpResponseBase): Observable<ProfileModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ProfileModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  updateProfiles(model: ProfileModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/profiles/update";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdateProfiles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateProfiles(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processUpdateProfiles(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IRolesClient {
  getAllRoles(): Observable<Role[]>;
  addPortalClaims(roleName: string, portalClaimModels: PortalClaimModel[]): Observable<void>;
  getPortalClaims(): Observable<RolePortalClaimModel[]>;
  getPortalClaimsByRole(roleName: string): Observable<RolePortalClaimModel[]>;
}

@Injectable({
  providedIn: 'root'
})
export class RolesClient implements IRolesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getAllRoles(): Observable<Role[]> {
    let url_ = this.baseUrl + "/api/roles";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAllRoles(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllRoles(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Role[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Role[]>;
    }));
  }

  protected processGetAllRoles(response: HttpResponseBase): Observable<Role[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Role[];
        return _observableOf(result200);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  addPortalClaims(roleName: string, portalClaimModels: PortalClaimModel[]): Observable<void> {
    let url_ = this.baseUrl + "/api/roles/{roleName}/claims/portal";
    if (roleName === undefined || roleName === null)
      throw new Error("The parameter 'roleName' must be defined.");
    url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(portalClaimModels);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAddPortalClaims(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAddPortalClaims(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAddPortalClaims(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getPortalClaims(): Observable<RolePortalClaimModel[]> {
    let url_ = this.baseUrl + "/api/roles/portal-claims";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetPortalClaims(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPortalClaims(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RolePortalClaimModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RolePortalClaimModel[]>;
    }));
  }

  protected processGetPortalClaims(response: HttpResponseBase): Observable<RolePortalClaimModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RolePortalClaimModel[];
        return _observableOf(result200);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getPortalClaimsByRole(roleName: string): Observable<RolePortalClaimModel[]> {
    let url_ = this.baseUrl + "/api/roles/{roleName}/claims";
    if (roleName === undefined || roleName === null)
      throw new Error("The parameter 'roleName' must be defined.");
    url_ = url_.replace("{roleName}", encodeURIComponent("" + roleName));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetPortalClaimsByRole(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetPortalClaimsByRole(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<RolePortalClaimModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<RolePortalClaimModel[]>;
    }));
  }

  protected processGetPortalClaimsByRole(response: HttpResponseBase): Observable<RolePortalClaimModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as RolePortalClaimModel[];
        return _observableOf(result200);
      }));
    } else if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IUserSessionClient {
  addActivity(model: UserActivityModel): Observable<void>;
}

@Injectable({
  providedIn: 'root'
})
export class UserSessionClient implements IUserSessionClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  addActivity(model: UserActivityModel): Observable<void> {
    let url_ = this.baseUrl + "/api/usersessions/add";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAddActivity(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAddActivity(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<void>;
        }
      } else
        return _observableThrow(response_) as any as Observable<void>;
    }));
  }

  protected processAddActivity(response: HttpResponseBase): Observable<void> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 500) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result500: any = null;
        result500 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ErrorCode;
        return throwException("A server side error occurred.", status, _responseText, _headers, result500);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IAppsClient {
  getOne(id: string, localeId: string): Observable<App>;
  getAll(): Observable<App[]>;
  getMany(localeId: string, ids: string | null | undefined): Observable<App[]>;
  getShortApps(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
  getAvailableUrls(id: string): Observable<AvailableUrl[]>;
  create(app: App): Observable<App>;
  getAllApps(localeId: string | null | undefined): Observable<App[]>;
  update(id: string, app: App): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
  updateMenu(id: string, menus: Menu[]): Observable<FileResponse>;
  asssignRolesToMenu(id: string, menuProfile: MenuProfile): Observable<FileResponse>;
  clone(model: CloneModel): Observable<FileResponse>;
  package(appId: string, model: PackageRequestModel): Observable<PackageResponseModel>;
  unpack(formFile: FileParameter | null | undefined): Observable<UnpackResponseModel>;
  install(model: InstallRequestModel): Observable<FileResponse>;
  preview(appId: string): Observable<PreviewPackageModel>;
}

@Injectable({
  providedIn: 'root'
})
export class AppsClient implements IAppsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getOne(id: string, localeId: string): Observable<App> {
    let url_ = this.baseUrl + "/api/apps/{id}/{localeId}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    if (localeId === undefined || localeId === null)
      throw new Error("The parameter 'localeId' must be defined.");
    url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<App>;
        }
      } else
        return _observableThrow(response_) as any as Observable<App>;
    }));
  }

  protected processGetOne(response: HttpResponseBase): Observable<App> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as App;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getAll(): Observable<App[]> {
    let url_ = this.baseUrl + "/api/apps/all-apps";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<App[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<App[]>;
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<App[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as App[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getMany(localeId: string, ids: string | null | undefined): Observable<App[]> {
    let url_ = this.baseUrl + "/api/apps/all/{localeId}?";
    if (localeId === undefined || localeId === null)
      throw new Error("The parameter 'localeId' must be defined.");
    url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
    if (ids !== undefined && ids !== null)
      url_ += "ids=" + encodeURIComponent("" + ids) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetMany(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetMany(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<App[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<App[]>;
    }));
  }

  protected processGetMany(response: HttpResponseBase): Observable<App[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as App[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getShortApps(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/apps/short-apps?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetShortApps(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetShortApps(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetShortApps(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getAvailableUrls(id: string): Observable<AvailableUrl[]> {
    let url_ = this.baseUrl + "/api/apps/{id}/urls";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAvailableUrls(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAvailableUrls(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<AvailableUrl[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<AvailableUrl[]>;
    }));
  }

  protected processGetAvailableUrls(response: HttpResponseBase): Observable<AvailableUrl[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as AvailableUrl[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  create(app: App): Observable<App> {
    let url_ = this.baseUrl + "/api/apps";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(app);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<App>;
        }
      } else
        return _observableThrow(response_) as any as Observable<App>;
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<App> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as App;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getAllApps(localeId: string | null | undefined): Observable<App[]> {
    let url_ = this.baseUrl + "/api/apps?";
    if (localeId !== undefined && localeId !== null)
      url_ += "localeId=" + encodeURIComponent("" + localeId) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAllApps(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllApps(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<App[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<App[]>;
    }));
  }

  protected processGetAllApps(response: HttpResponseBase): Observable<App[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as App[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  update(id: string, app: App): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/apps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(app);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/apps/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  updateMenu(id: string, menus: Menu[]): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/apps/{id}/menus";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(menus);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdateMenu(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateMenu(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processUpdateMenu(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  asssignRolesToMenu(id: string, menuProfile: MenuProfile): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/apps/{id}/menus/assign-role";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(menuProfile);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processAsssignRolesToMenu(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processAsssignRolesToMenu(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processAsssignRolesToMenu(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  clone(model: CloneModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/apps/clone";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processClone(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processClone(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processClone(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  package(appId: string, model: PackageRequestModel): Observable<PackageResponseModel> {
    let url_ = this.baseUrl + "/api/apps/{appId}/package";
    if (appId === undefined || appId === null)
      throw new Error("The parameter 'appId' must be defined.");
    url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPackage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPackage(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PackageResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PackageResponseModel>;
    }));
  }

  protected processPackage(response: HttpResponseBase): Observable<PackageResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PackageResponseModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  unpack(formFile: FileParameter | null | undefined): Observable<UnpackResponseModel> {
    let url_ = this.baseUrl + "/api/apps/unpackage";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (formFile !== null && formFile !== undefined)
      content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUnpack(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUnpack(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UnpackResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UnpackResponseModel>;
    }));
  }

  protected processUnpack(response: HttpResponseBase): Observable<UnpackResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UnpackResponseModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  install(model: InstallRequestModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/apps/install";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processInstall(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processInstall(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processInstall(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  preview(appId: string): Observable<PreviewPackageModel> {
    let url_ = this.baseUrl + "/api/apps/{appId}/preview";
    if (appId === undefined || appId === null)
      throw new Error("The parameter 'appId' must be defined.");
    url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPreview(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPreview(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PreviewPackageModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PreviewPackageModel>;
    }));
  }

  protected processPreview(response: HttpResponseBase): Observable<PreviewPackageModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PreviewPackageModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IBackupsClient {
  getOne(id: string): Observable<Backup>;
  uploadBackupFile(formFile: FileParameter | null | undefined): Observable<UploadBackupResponseModel>;
  create(model: BackupRequestModel): Observable<BackupResponseModel>;
  previewBackup(id: string): Observable<PreviewRestoreModel>;
  restoreBackup(id: string, model: RestoreRequestModel): Observable<FileResponse>;
  generateCode(model: GenerateCodeRequestModel): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class BackupsClient implements IBackupsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getOne(id: string): Observable<Backup> {
    let url_ = this.baseUrl + "/api/backups/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Backup>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Backup>;
    }));
  }

  protected processGetOne(response: HttpResponseBase): Observable<Backup> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Backup;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  uploadBackupFile(formFile: FileParameter | null | undefined): Observable<UploadBackupResponseModel> {
    let url_ = this.baseUrl + "/api/backups/upload";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (formFile !== null && formFile !== undefined)
      content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUploadBackupFile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUploadBackupFile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<UploadBackupResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<UploadBackupResponseModel>;
    }));
  }

  protected processUploadBackupFile(response: HttpResponseBase): Observable<UploadBackupResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as UploadBackupResponseModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  create(model: BackupRequestModel): Observable<BackupResponseModel> {
    let url_ = this.baseUrl + "/api/backups";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<BackupResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<BackupResponseModel>;
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<BackupResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as BackupResponseModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  previewBackup(id: string): Observable<PreviewRestoreModel> {
    let url_ = this.baseUrl + "/api/backups/{id}/preview";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPreviewBackup(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPreviewBackup(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PreviewRestoreModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PreviewRestoreModel>;
    }));
  }

  protected processPreviewBackup(response: HttpResponseBase): Observable<PreviewRestoreModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PreviewRestoreModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  restoreBackup(id: string, model: RestoreRequestModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/backups/{id}/restore";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processRestoreBackup(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processRestoreBackup(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processRestoreBackup(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  generateCode(model: GenerateCodeRequestModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/backups/generate-code";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGenerateCode(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGenerateCode(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processGenerateCode(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IChartsClient {
  getMany(): Observable<Chart[]>;
  create(chart: Chart): Observable<Chart>;
  getOne(id: string): Observable<Chart>;
  update(id: string, chart: Chart): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
  getOneForBuilder(id: string): Observable<Chart>;
  getShortCharts(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
  checkExist(name: string): Observable<boolean>;
  extraction(model: ExtractingChartQueryModel): Observable<ExtractionChartFilter>;
  execution(model: ExecutionChartRequestModel): Observable<ExecutionChartResponseModel>;
  clone(model: CloneModel): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class ChartsClient implements IChartsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getMany(): Observable<Chart[]> {
    let url_ = this.baseUrl + "/api/charts";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetMany(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetMany(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Chart[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Chart[]>;
    }));
  }

  protected processGetMany(response: HttpResponseBase): Observable<Chart[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Chart[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  create(chart: Chart): Observable<Chart> {
    let url_ = this.baseUrl + "/api/charts";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(chart);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Chart>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Chart>;
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<Chart> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Chart;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getOne(id: string): Observable<Chart> {
    let url_ = this.baseUrl + "/api/charts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Chart>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Chart>;
    }));
  }

  protected processGetOne(response: HttpResponseBase): Observable<Chart> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Chart;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  update(id: string, chart: Chart): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/charts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(chart);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/charts/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getOneForBuilder(id: string): Observable<Chart> {
    let url_ = this.baseUrl + "/api/charts/{id}/builder";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOneForBuilder(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOneForBuilder(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Chart>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Chart>;
    }));
  }

  protected processGetOneForBuilder(response: HttpResponseBase): Observable<Chart> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Chart;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getShortCharts(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/charts/short-charts?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetShortCharts(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetShortCharts(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetShortCharts(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  checkExist(name: string): Observable<boolean> {
    let url_ = this.baseUrl + "/api/charts/check-exist/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCheckExist(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCheckExist(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<boolean>;
        }
      } else
        return _observableThrow(response_) as any as Observable<boolean>;
    }));
  }

  protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  extraction(model: ExtractingChartQueryModel): Observable<ExtractionChartFilter> {
    let url_ = this.baseUrl + "/api/charts/extract";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExtraction(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExtraction(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExtractionChartFilter>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExtractionChartFilter>;
    }));
  }

  protected processExtraction(response: HttpResponseBase): Observable<ExtractionChartFilter> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExtractionChartFilter;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  execution(model: ExecutionChartRequestModel): Observable<ExecutionChartResponseModel> {
    let url_ = this.baseUrl + "/api/charts/execution";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExecution(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExecution(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExecutionChartResponseModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExecutionChartResponseModel>;
    }));
  }

  protected processExecution(response: HttpResponseBase): Observable<ExecutionChartResponseModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExecutionChartResponseModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  clone(model: CloneModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/charts/clone";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processClone(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processClone(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processClone(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface ICompositeControlsClient {
  get(id: string): Observable<CompositeControl>;
  update(id: string, model: CompositeControl): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
  getAll(ids: string | null | undefined): Observable<CompositeControl[]>;
  create(model: CompositeControl): Observable<FileResponse>;
  getShortControls(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
}

@Injectable({
  providedIn: 'root'
})
export class CompositeControlsClient implements ICompositeControlsClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  get(id: string): Observable<CompositeControl> {
    let url_ = this.baseUrl + "/api/composite-controls/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CompositeControl>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CompositeControl>;
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<CompositeControl> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompositeControl;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  update(id: string, model: CompositeControl): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/composite-controls/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/composite-controls/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getAll(ids: string | null | undefined): Observable<CompositeControl[]> {
    let url_ = this.baseUrl + "/api/composite-controls?";
    if (ids !== undefined && ids !== null)
      url_ += "ids=" + encodeURIComponent("" + ids) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<CompositeControl[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<CompositeControl[]>;
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<CompositeControl[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as CompositeControl[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  create(model: CompositeControl): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/composite-controls";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getShortControls(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/composite-controls/short-controls?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetShortControls(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetShortControls(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetShortControls(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IDatabasesClient {
  getAll(): Observable<DatabaseConnection[]>;
  post(databaseConnection: DatabaseConnection): Observable<DatabaseConnection>;
  get(id: string): Observable<DatabaseConnection>;
  put(id: string, databaseConnection: DatabaseConnection): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
  getShortDatabases(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
  executionDynamic(databaseId: string, content: any): Observable<ExecuteDynamicResultModel>;
  extractingQuery(databaseId: string, model: ExtractionDatabaseRequestModel): Observable<ExtractingSchemaQueryModel>;
  executeQueryDatasource(databaseId: string, content: any): Observable<ExecuteDynamicResultModel>;
  clone(model: CloneModel): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class DatabasesClient implements IDatabasesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getAll(): Observable<DatabaseConnection[]> {
    let url_ = this.baseUrl + "/api/databases";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DatabaseConnection[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DatabaseConnection[]>;
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<DatabaseConnection[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DatabaseConnection[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  post(databaseConnection: DatabaseConnection): Observable<DatabaseConnection> {
    let url_ = this.baseUrl + "/api/databases";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(databaseConnection);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPost(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPost(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DatabaseConnection>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DatabaseConnection>;
    }));
  }

  protected processPost(response: HttpResponseBase): Observable<DatabaseConnection> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DatabaseConnection;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  get(id: string): Observable<DatabaseConnection> {
    let url_ = this.baseUrl + "/api/databases/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DatabaseConnection>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DatabaseConnection>;
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<DatabaseConnection> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DatabaseConnection;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  put(id: string, databaseConnection: DatabaseConnection): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/databases/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(databaseConnection);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processPut(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processPut(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processPut(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/databases/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getShortDatabases(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/databases/short-databases?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetShortDatabases(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetShortDatabases(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetShortDatabases(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  executionDynamic(databaseId: string, content: any): Observable<ExecuteDynamicResultModel> {
    let url_ = this.baseUrl + "/api/databases/{databaseId}/execution";
    if (databaseId === undefined || databaseId === null)
      throw new Error("The parameter 'databaseId' must be defined.");
    url_ = url_.replace("{databaseId}", encodeURIComponent("" + databaseId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(content);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExecutionDynamic(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExecutionDynamic(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExecuteDynamicResultModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExecuteDynamicResultModel>;
    }));
  }

  protected processExecutionDynamic(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExecuteDynamicResultModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  extractingQuery(databaseId: string, model: ExtractionDatabaseRequestModel): Observable<ExtractingSchemaQueryModel> {
    let url_ = this.baseUrl + "/api/databases/{databaseId}/extract-raw";
    if (databaseId === undefined || databaseId === null)
      throw new Error("The parameter 'databaseId' must be defined.");
    url_ = url_.replace("{databaseId}", encodeURIComponent("" + databaseId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExtractingQuery(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExtractingQuery(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExtractingSchemaQueryModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExtractingSchemaQueryModel>;
    }));
  }

  protected processExtractingQuery(response: HttpResponseBase): Observable<ExtractingSchemaQueryModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExtractingSchemaQueryModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  executeQueryDatasource(databaseId: string, content: any): Observable<ExecuteDynamicResultModel> {
    let url_ = this.baseUrl + "/api/databases/{databaseId}/query-datasource";
    if (databaseId === undefined || databaseId === null)
      throw new Error("The parameter 'databaseId' must be defined.");
    url_ = url_.replace("{databaseId}", encodeURIComponent("" + databaseId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(content);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExecuteQueryDatasource(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExecuteQueryDatasource(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExecuteDynamicResultModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExecuteDynamicResultModel>;
    }));
  }

  protected processExecuteQueryDatasource(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExecuteDynamicResultModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  clone(model: CloneModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/databases/clone";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processClone(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processClone(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processClone(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IDynamicListClient {
  getAll(): Observable<DynamicList[]>;
  create(dynamicList: DynamicList): Observable<DynamicList>;
  getOne(id: string): Observable<DynamicList>;
  update(id: string, dynamicList: DynamicList): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
  getOneForRender(id: string): Observable<DynamicList>;
  getShortDynamicLists(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
  executeQuery(id: string, fetchDataModel: DynamicListFetchDataModel): Observable<DynamicListResponseDataModel>;
  extractingQuery(extractingQuery: ExtractingQueryModel): Observable<PopulateQueryModel>;
  checkExist(name: string): Observable<boolean>;
  clone(model: CloneModel): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class DynamicListClient implements IDynamicListClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getAll(): Observable<DynamicList[]> {
    let url_ = this.baseUrl + "/api/dynamiclists";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DynamicList[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DynamicList[]>;
    }));
  }

  protected processGetAll(response: HttpResponseBase): Observable<DynamicList[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DynamicList[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  create(dynamicList: DynamicList): Observable<DynamicList> {
    let url_ = this.baseUrl + "/api/dynamiclists";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(dynamicList);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DynamicList>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DynamicList>;
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<DynamicList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DynamicList;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getOne(id: string): Observable<DynamicList> {
    let url_ = this.baseUrl + "/api/dynamiclists/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DynamicList>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DynamicList>;
    }));
  }

  protected processGetOne(response: HttpResponseBase): Observable<DynamicList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DynamicList;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  update(id: string, dynamicList: DynamicList): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/dynamiclists/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(dynamicList);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/dynamiclists/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getOneForRender(id: string): Observable<DynamicList> {
    let url_ = this.baseUrl + "/api/dynamiclists/{id}/render";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOneForRender(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOneForRender(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DynamicList>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DynamicList>;
    }));
  }

  protected processGetOneForRender(response: HttpResponseBase): Observable<DynamicList> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DynamicList;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getShortDynamicLists(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/dynamiclists/short-dynamiclists?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetShortDynamicLists(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetShortDynamicLists(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetShortDynamicLists(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  executeQuery(id: string, fetchDataModel: DynamicListFetchDataModel): Observable<DynamicListResponseDataModel> {
    let url_ = this.baseUrl + "/api/dynamiclists/{id}/fetch-data";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(fetchDataModel);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExecuteQuery(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExecuteQuery(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<DynamicListResponseDataModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<DynamicListResponseDataModel>;
    }));
  }

  protected processExecuteQuery(response: HttpResponseBase): Observable<DynamicListResponseDataModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as DynamicListResponseDataModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  extractingQuery(extractingQuery: ExtractingQueryModel): Observable<PopulateQueryModel> {
    let url_ = this.baseUrl + "/api/dynamiclists/extract-query";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(extractingQuery);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExtractingQuery(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExtractingQuery(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<PopulateQueryModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<PopulateQueryModel>;
    }));
  }

  protected processExtractingQuery(response: HttpResponseBase): Observable<PopulateQueryModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as PopulateQueryModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  checkExist(name: string): Observable<boolean> {
    let url_ = this.baseUrl + "/api/dynamiclists/check-exist/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCheckExist(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCheckExist(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<boolean>;
        }
      } else
        return _observableThrow(response_) as any as Observable<boolean>;
    }));
  }

  protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  clone(model: CloneModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/dynamiclists/clone";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processClone(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processClone(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processClone(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IEntitySchemasClient {
  getOne(databaseId: string, entityName: string): Observable<EntitySchema>;
  fetchAllFromDatabase(id: string): Observable<EntitySchema[]>;
  getAllFromOneDatabase(id: string): Observable<EntitySchema[]>;
  flushOneDatabase(flushDatabaseModel: FlushDatabaseModel): Observable<EntitySchema[]>;
  delete(id: string): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class EntitySchemasClient implements IEntitySchemasClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getOne(databaseId: string, entityName: string): Observable<EntitySchema> {
    let url_ = this.baseUrl + "/api/entity-schemas/{entityName}/{databaseId}";
    if (databaseId === undefined || databaseId === null)
      throw new Error("The parameter 'databaseId' must be defined.");
    url_ = url_.replace("{databaseId}", encodeURIComponent("" + databaseId));
    if (entityName === undefined || entityName === null)
      throw new Error("The parameter 'entityName' must be defined.");
    url_ = url_.replace("{entityName}", encodeURIComponent("" + entityName));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<EntitySchema>;
        }
      } else
        return _observableThrow(response_) as any as Observable<EntitySchema>;
    }));
  }

  protected processGetOne(response: HttpResponseBase): Observable<EntitySchema> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EntitySchema;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  fetchAllFromDatabase(id: string): Observable<EntitySchema[]> {
    let url_ = this.baseUrl + "/api/entity-schemas/fetch/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processFetchAllFromDatabase(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processFetchAllFromDatabase(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<EntitySchema[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<EntitySchema[]>;
    }));
  }

  protected processFetchAllFromDatabase(response: HttpResponseBase): Observable<EntitySchema[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EntitySchema[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getAllFromOneDatabase(id: string): Observable<EntitySchema[]> {
    let url_ = this.baseUrl + "/api/entity-schemas/database/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAllFromOneDatabase(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllFromOneDatabase(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<EntitySchema[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<EntitySchema[]>;
    }));
  }

  protected processGetAllFromOneDatabase(response: HttpResponseBase): Observable<EntitySchema[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EntitySchema[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  flushOneDatabase(flushDatabaseModel: FlushDatabaseModel): Observable<EntitySchema[]> {
    let url_ = this.baseUrl + "/api/entity-schemas/flush";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(flushDatabaseModel);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processFlushOneDatabase(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processFlushOneDatabase(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<EntitySchema[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<EntitySchema[]>;
    }));
  }

  protected processFlushOneDatabase(response: HttpResponseBase): Observable<EntitySchema[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as EntitySchema[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/entity-schemas/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IFilesClient {
  upload(formFile: FileParameter | null | undefined): Observable<ResponseUploadFile>;
  getFileInfo(fileId: string): Observable<File>;
  getFile(fileId: string, compress: boolean | null | undefined): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class FilesClient implements IFilesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  upload(formFile: FileParameter | null | undefined): Observable<ResponseUploadFile> {
    let url_ = this.baseUrl + "/api/files/upload";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = new FormData();
    if (formFile !== null && formFile !== undefined)
      content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpload(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpload(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ResponseUploadFile>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ResponseUploadFile>;
    }));
  }

  protected processUpload(response: HttpResponseBase): Observable<ResponseUploadFile> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ResponseUploadFile;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getFileInfo(fileId: string): Observable<File> {
    let url_ = this.baseUrl + "/api/files/metadata/{fileId}";
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.");
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetFileInfo(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetFileInfo(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<File>;
        }
      } else
        return _observableThrow(response_) as any as Observable<File>;
    }));
  }

  protected processGetFileInfo(response: HttpResponseBase): Observable<File> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as File;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getFile(fileId: string, compress: boolean | null | undefined): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/files/download/{fileId}?";
    if (fileId === undefined || fileId === null)
      throw new Error("The parameter 'fileId' must be defined.");
    url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
    if (compress !== undefined && compress !== null)
      url_ += "compress=" + encodeURIComponent("" + compress) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetFile(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetFile(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processGetFile(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface ILocalizationClient {
  getOne(appId: string, localeId: string): Observable<Localization>;
  checkExist(appId: string, localeId: string): Observable<Localization>;
  collectAll(appId: string): Observable<LanguageKey[]>;
  create(localization: Localization): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class LocalizationClient implements ILocalizationClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getOne(appId: string, localeId: string): Observable<Localization> {
    let url_ = this.baseUrl + "/api/localizations/{appId}/{localeId}";
    if (appId === undefined || appId === null)
      throw new Error("The parameter 'appId' must be defined.");
    url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
    if (localeId === undefined || localeId === null)
      throw new Error("The parameter 'localeId' must be defined.");
    url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Localization>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Localization>;
    }));
  }

  protected processGetOne(response: HttpResponseBase): Observable<Localization> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Localization;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  checkExist(appId: string, localeId: string): Observable<Localization> {
    let url_ = this.baseUrl + "/api/localizations/exist/{appId}/{localeId}";
    if (appId === undefined || appId === null)
      throw new Error("The parameter 'appId' must be defined.");
    url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
    if (localeId === undefined || localeId === null)
      throw new Error("The parameter 'localeId' must be defined.");
    url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCheckExist(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCheckExist(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Localization>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Localization>;
    }));
  }

  protected processCheckExist(response: HttpResponseBase): Observable<Localization> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Localization;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  collectAll(appId: string): Observable<LanguageKey[]> {
    let url_ = this.baseUrl + "/api/localizations/collectAll/{appId}";
    if (appId === undefined || appId === null)
      throw new Error("The parameter 'appId' must be defined.");
    url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCollectAll(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCollectAll(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<LanguageKey[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<LanguageKey[]>;
    }));
  }

  protected processCollectAll(response: HttpResponseBase): Observable<LanguageKey[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LanguageKey[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  create(localization: Localization): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/localizations";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(localization);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/localizations/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IPagesClient {
  getAllShortPages(): Observable<ShortPageModel[]>;
  getAllPortalClaims(): Observable<ShortPortalClaimModel[]>;
  getOneById(id: string): Observable<Page>;
  getOne(name: string): Observable<Page>;
  getOneForRender(name: string): Observable<Page>;
  getShortPages(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
  create(page: Page): Observable<string>;
  update(id: string, page: Page): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
  checkExist(name: string): Observable<boolean>;
  submitCommand(pageId: string, pageSubmittedButtonModel: PageSubmittedButtonModel): Observable<ExecuteDynamicResultModel>;
  fetchControlDatasource(pageId: string, model: PageSelectionDatasourceModel): Observable<ExecuteDynamicResultModel>;
  executeTriggeredEvent(pageId: string, model: PageTriggeringEventModel): Observable<ExecuteDynamicResultModel>;
  executeAsyncValidator(pageId: string, validatorModel: PageAsyncValidatorModel): Observable<ExecuteDynamicResultModel>;
  getDatasourceForPage(pageId: string, pageRequestDatasourceModel: PageRequestDatasourceModel): Observable<ExecuteDynamicResultModel>;
  clone(model: CloneModel): Observable<FileResponse>;
  generateLanguages(id: string): Observable<LanguageKey[]>;
}

@Injectable({
  providedIn: 'root'
})
export class PagesClient implements IPagesClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getAllShortPages(): Observable<ShortPageModel[]> {
    let url_ = this.baseUrl + "/api/pages/shorts";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAllShortPages(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllShortPages(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortPageModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortPageModel[]>;
    }));
  }

  protected processGetAllShortPages(response: HttpResponseBase): Observable<ShortPageModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortPageModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getAllPortalClaims(): Observable<ShortPortalClaimModel[]> {
    let url_ = this.baseUrl + "/api/pages/all-claims";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetAllPortalClaims(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetAllPortalClaims(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortPortalClaimModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortPortalClaimModel[]>;
    }));
  }

  protected processGetAllPortalClaims(response: HttpResponseBase): Observable<ShortPortalClaimModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortPortalClaimModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getOneById(id: string): Observable<Page> {
    let url_ = this.baseUrl + "/api/pages/get-by-id/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOneById(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOneById(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Page>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Page>;
    }));
  }

  protected processGetOneById(response: HttpResponseBase): Observable<Page> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Page;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getOne(name: string): Observable<Page> {
    let url_ = this.baseUrl + "/api/pages/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Page>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Page>;
    }));
  }

  protected processGetOne(response: HttpResponseBase): Observable<Page> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Page;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getOneForRender(name: string): Observable<Page> {
    let url_ = this.baseUrl + "/api/pages/render/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOneForRender(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOneForRender(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<Page>;
        }
      } else
        return _observableThrow(response_) as any as Observable<Page>;
    }));
  }

  protected processGetOneForRender(response: HttpResponseBase): Observable<Page> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as Page;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getShortPages(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/pages/short-pages?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetShortPages(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetShortPages(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetShortPages(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  create(page: Page): Observable<string> {
    let url_ = this.baseUrl + "/api/pages";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(page);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  protected processCreate(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  update(id: string, page: Page): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/pages/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(page);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdate(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdate(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/pages/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  checkExist(name: string): Observable<boolean> {
    let url_ = this.baseUrl + "/api/pages/check-exist/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCheckExist(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCheckExist(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<boolean>;
        }
      } else
        return _observableThrow(response_) as any as Observable<boolean>;
    }));
  }

  protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  submitCommand(pageId: string, pageSubmittedButtonModel: PageSubmittedButtonModel): Observable<ExecuteDynamicResultModel> {
    let url_ = this.baseUrl + "/api/pages/{pageId}/submit";
    if (pageId === undefined || pageId === null)
      throw new Error("The parameter 'pageId' must be defined.");
    url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(pageSubmittedButtonModel);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processSubmitCommand(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processSubmitCommand(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExecuteDynamicResultModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExecuteDynamicResultModel>;
    }));
  }

  protected processSubmitCommand(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExecuteDynamicResultModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  fetchControlDatasource(pageId: string, model: PageSelectionDatasourceModel): Observable<ExecuteDynamicResultModel> {
    let url_ = this.baseUrl + "/api/pages/{pageId}/fetch-control-datasource";
    if (pageId === undefined || pageId === null)
      throw new Error("The parameter 'pageId' must be defined.");
    url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processFetchControlDatasource(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processFetchControlDatasource(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExecuteDynamicResultModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExecuteDynamicResultModel>;
    }));
  }

  protected processFetchControlDatasource(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExecuteDynamicResultModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  executeTriggeredEvent(pageId: string, model: PageTriggeringEventModel): Observable<ExecuteDynamicResultModel> {
    let url_ = this.baseUrl + "/api/pages/{pageId}/trigger-control-event";
    if (pageId === undefined || pageId === null)
      throw new Error("The parameter 'pageId' must be defined.");
    url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExecuteTriggeredEvent(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExecuteTriggeredEvent(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExecuteDynamicResultModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExecuteDynamicResultModel>;
    }));
  }

  protected processExecuteTriggeredEvent(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExecuteDynamicResultModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  executeAsyncValidator(pageId: string, validatorModel: PageAsyncValidatorModel): Observable<ExecuteDynamicResultModel> {
    let url_ = this.baseUrl + "/api/pages/{pageId}/async-validator";
    if (pageId === undefined || pageId === null)
      throw new Error("The parameter 'pageId' must be defined.");
    url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(validatorModel);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processExecuteAsyncValidator(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processExecuteAsyncValidator(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExecuteDynamicResultModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExecuteDynamicResultModel>;
    }));
  }

  protected processExecuteAsyncValidator(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExecuteDynamicResultModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getDatasourceForPage(pageId: string, pageRequestDatasourceModel: PageRequestDatasourceModel): Observable<ExecuteDynamicResultModel> {
    let url_ = this.baseUrl + "/api/pages/{pageId}/fetch-datasource";
    if (pageId === undefined || pageId === null)
      throw new Error("The parameter 'pageId' must be defined.");
    url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(pageRequestDatasourceModel);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetDatasourceForPage(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetDatasourceForPage(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ExecuteDynamicResultModel>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ExecuteDynamicResultModel>;
    }));
  }

  protected processGetDatasourceForPage(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ExecuteDynamicResultModel;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  clone(model: CloneModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/pages/clone";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processClone(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processClone(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processClone(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  generateLanguages(id: string): Observable<LanguageKey[]> {
    let url_ = this.baseUrl + "/api/pages/{id}/languages";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGenerateLanguages(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGenerateLanguages(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<LanguageKey[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<LanguageKey[]>;
    }));
  }

  protected processGenerateLanguages(response: HttpResponseBase): Observable<LanguageKey[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as LanguageKey[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IStandardComponentClient {
  getOne(id: string): Observable<StandardComponent>;
  updateOne(id: string, standardComponent: StandardComponent): Observable<FileResponse>;
  delete(id: string): Observable<FileResponse>;
  getOneForRender(id: string): Observable<StandardComponent>;
  getSortStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
  getSortArrayStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
  getSortTreeStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
  createOne(standardComponent: StandardComponent): Observable<string>;
  createBulk(standardComponents: StandardComponent[]): Observable<FileResponse>;
  getManys(ids: string | null | undefined): Observable<StandardComponent[]>;
  getArrayStandards(ids: string | null | undefined): Observable<StandardComponent[]>;
  getTreeStandards(ids: string | null | undefined): Observable<StandardComponent[]>;
  checkExist(name: string): Observable<boolean>;
  clone(model: CloneModel): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class StandardComponentClient implements IStandardComponentClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  getOne(id: string): Observable<StandardComponent> {
    let url_ = this.baseUrl + "/api/standards/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StandardComponent>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StandardComponent>;
    }));
  }

  protected processGetOne(response: HttpResponseBase): Observable<StandardComponent> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StandardComponent;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  updateOne(id: string, standardComponent: StandardComponent): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/standards/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(standardComponent);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processUpdateOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processUpdateOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processUpdateOne(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  delete(id: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/standards/{id}";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processDelete(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processDelete(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getOneForRender(id: string): Observable<StandardComponent> {
    let url_ = this.baseUrl + "/api/standards/{id}/render";
    if (id === undefined || id === null)
      throw new Error("The parameter 'id' must be defined.");
    url_ = url_.replace("{id}", encodeURIComponent("" + id));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetOneForRender(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetOneForRender(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StandardComponent>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StandardComponent>;
    }));
  }

  protected processGetOneForRender(response: HttpResponseBase): Observable<StandardComponent> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StandardComponent;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getSortStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/standards/short-standards?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetSortStandards(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetSortStandards(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetSortStandards(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getSortArrayStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/standards/short-array-standards?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetSortArrayStandards(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetSortArrayStandards(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetSortArrayStandards(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getSortTreeStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
    let url_ = this.baseUrl + "/api/standards/short-tree-standards?";
    if (keyWord !== undefined && keyWord !== null)
      url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetSortTreeStandards(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetSortTreeStandards(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<ShortEntityModel[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<ShortEntityModel[]>;
    }));
  }

  protected processGetSortTreeStandards(response: HttpResponseBase): Observable<ShortEntityModel[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as ShortEntityModel[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  createOne(standardComponent: StandardComponent): Observable<string> {
    let url_ = this.baseUrl + "/api/standards";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(standardComponent);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/json"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreateOne(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateOne(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<string>;
        }
      } else
        return _observableThrow(response_) as any as Observable<string>;
    }));
  }

  protected processCreateOne(response: HttpResponseBase): Observable<string> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as string;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  createBulk(standardComponents: StandardComponent[]): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/standards/bulk";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(standardComponents);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCreateBulk(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCreateBulk(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processCreateBulk(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getManys(ids: string | null | undefined): Observable<StandardComponent[]> {
    let url_ = this.baseUrl + "/api/standards/bulk?";
    if (ids !== undefined && ids !== null)
      url_ += "ids=" + encodeURIComponent("" + ids) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetManys(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetManys(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StandardComponent[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StandardComponent[]>;
    }));
  }

  protected processGetManys(response: HttpResponseBase): Observable<StandardComponent[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StandardComponent[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getArrayStandards(ids: string | null | undefined): Observable<StandardComponent[]> {
    let url_ = this.baseUrl + "/api/standards/bulk-array?";
    if (ids !== undefined && ids !== null)
      url_ += "ids=" + encodeURIComponent("" + ids) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetArrayStandards(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetArrayStandards(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StandardComponent[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StandardComponent[]>;
    }));
  }

  protected processGetArrayStandards(response: HttpResponseBase): Observable<StandardComponent[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StandardComponent[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  getTreeStandards(ids: string | null | undefined): Observable<StandardComponent[]> {
    let url_ = this.baseUrl + "/api/standards/bulk-tree?";
    if (ids !== undefined && ids !== null)
      url_ += "ids=" + encodeURIComponent("" + ids) + "&";
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGetTreeStandards(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGetTreeStandards(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<StandardComponent[]>;
        }
      } else
        return _observableThrow(response_) as any as Observable<StandardComponent[]>;
    }));
  }

  protected processGetTreeStandards(response: HttpResponseBase): Observable<StandardComponent[]> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as StandardComponent[];
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  checkExist(name: string): Observable<boolean> {
    let url_ = this.baseUrl + "/api/standards/check-exist/{name}";
    if (name === undefined || name === null)
      throw new Error("The parameter 'name' must be defined.");
    url_ = url_.replace("{name}", encodeURIComponent("" + name));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/json"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processCheckExist(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processCheckExist(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<boolean>;
        }
      } else
        return _observableThrow(response_) as any as Observable<boolean>;
    }));
  }

  protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        let result200: any = null;
        result200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver) as boolean;
        return _observableOf(result200);
      }));
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }

  clone(model: CloneModel): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/standards/clone";
    url_ = url_.replace(/[?&]$/, "");

    const content_ = JSON.stringify(model);

    let options_ : any = {
      body: content_,
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Content-Type": "application/json",
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processClone(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processClone(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processClone(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface IConfigurationClient {
  get(serviceName: string, version: string): Observable<FileResponse>;
}

@Injectable({
  providedIn: 'root'
})
export class ConfigurationClient implements IConfigurationClient {
  private http: HttpClient;
  private baseUrl: string;
  protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

  constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
    this.http = http;
    this.baseUrl = baseUrl ?? "https://localhost:5102";
  }

  get(serviceName: string, version: string): Observable<FileResponse> {
    let url_ = this.baseUrl + "/api/configurations/{serviceName}/{version}";
    if (serviceName === undefined || serviceName === null)
      throw new Error("The parameter 'serviceName' must be defined.");
    url_ = url_.replace("{serviceName}", encodeURIComponent("" + serviceName));
    if (version === undefined || version === null)
      throw new Error("The parameter 'version' must be defined.");
    url_ = url_.replace("{version}", encodeURIComponent("" + version));
    url_ = url_.replace(/[?&]$/, "");

    let options_ : any = {
      observe: "response",
      responseType: "blob",
      headers: new HttpHeaders({
        "Accept": "application/octet-stream"
      })
    };

    return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
      return this.processGet(response_);
    })).pipe(_observableCatch((response_: any) => {
      if (response_ instanceof HttpResponseBase) {
        try {
          return this.processGet(response_ as any);
        } catch (e) {
          return _observableThrow(e) as any as Observable<FileResponse>;
        }
      } else
        return _observableThrow(response_) as any as Observable<FileResponse>;
    }));
  }

  protected processGet(response: HttpResponseBase): Observable<FileResponse> {
    const status = response.status;
    const responseBlob =
      response instanceof HttpResponse ? response.body :
        (response as any).error instanceof Blob ? (response as any).error : undefined;

    let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
    if (status === 200 || status === 206) {
      const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
      let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
      let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
      if (fileName) {
        fileName = decodeURIComponent(fileName);
      } else {
        fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
        fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
      }
      return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
    } else if (status !== 200 && status !== 204) {
      return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
        return throwException("An unexpected server error occurred.", status, _responseText, _headers);
      }));
    }
    return _observableOf(null as any);
  }
}

export interface TokenModel {
  token?: string | undefined;
  exp?: number;
  refreshToken?: string | undefined;
  expRefresh?: number;
  userSessionId?: string | undefined;
}

export interface ErrorCode {
  messageCode?: string | undefined;
  messageContent?: string | undefined;
}

export interface LoginModel {
  username: string;
  password: string;
  versionInstalled?: string | undefined;
  softwareAgent?: string | undefined;
  clientIp?: string | undefined;
}

export interface LogoutModel {
  username?: string | undefined;
  token?: string | undefined;
  userSession?: string | undefined;
}

export interface RegisterModel {
  username: string;
  password: string;
  repassword: string;
  email: string;
}

export interface ForgotPasswordModel {
  email: string;
}

export interface RecoveryPasswordModel {
  validateCode?: string | undefined;
  userId?: string | undefined;
  newPassword?: string | undefined;
}

export interface ChangePasswordModel {
  currentPassword: string;
  newPassword: string;
  reNewPassword: string;
}

export interface ProfileModel {
  fullName: string;
  avatar: string;
}

export interface Entity {
  id?: string | undefined;
}

export interface Role extends Entity {
  name?: string | undefined;
  displayName?: string | undefined;
  normalizedName?: string | undefined;
  claims?: BaseClaim[] | undefined;
}

export interface BaseClaim {
  claimType?: string | undefined;
  claimValue?: string | undefined;
  issuer?: string | undefined;
  claimValueType?: string | undefined;
}

export interface PortalClaimModel {
  name?: string | undefined;
  value?: string | undefined;
}

export interface RolePortalClaimModel {
  name?: string | undefined;
  claims?: string[] | undefined;
}

export interface UserActivityModel {
  userSessionId: string;
  traceId: string;
  activityName: string;
  content: string;
  activityType?: ActivityType;
}

export enum ActivityType {
  Info = 0,
  Warn = 1,
  Critical = 2,
}

export interface BackupableEntity extends Entity {
  name?: string | undefined;
  displayName?: string | undefined;
  timeSpan?: number;
}

export interface App extends BackupableEntity {
  logo?: string | undefined;
  defaultUrl?: string | undefined;
  author?: string | undefined;
  currentVersionNumber?: string | undefined;
  createdDate?: Date;
  modifiedDate?: Date;
  menus?: Menu[] | undefined;
  menuProfiles?: MenuProfile[] | undefined;
}

export interface Menu {
  id?: string | undefined;
  displayName?: string | undefined;
  icon?: string | undefined;
  url?: string | undefined;
  order?: number;
  parentId?: string | undefined;
  menuPath?: string | undefined;
  hide?: boolean;
  subMenus?: Menu[] | undefined;
}

export interface MenuProfile {
  role?: string | undefined;
  menuIds?: string[] | undefined;
}

export interface ShortEntityModel {
  id?: string | undefined;
  displayName?: string | undefined;
  appId?: string | undefined;
}

export interface AvailableUrl {
  url?: string | undefined;
  name?: string | undefined;
  pageId?: string | undefined;
}

export interface CloneModel {
  cloneId?: string | undefined;
  cloneName?: string | undefined;
}

export interface PackageResponseModel {
  downloadableUrl?: string | undefined;
}

export interface PackageRequestModel {
  description: string;
  creator: string;
  appId: string;
}

export interface UnpackResponseModel {
  uploadFileId?: string | undefined;
  description?: string | undefined;
  creator?: string | undefined;
  packagedDate?: Date;
  app?: App | undefined;
  standards?: ComponentInstallState[] | undefined;
  dynamicLists?: ComponentInstallState[] | undefined;
  charts?: ComponentInstallState[] | undefined;
  pages?: ComponentInstallState[] | undefined;
  locales?: ComponentInstallState[] | undefined;
  totalStandards?: number;
  totalCharts?: number;
  totalDynamicLists?: number;
  totalPages?: number;
  totalLocales?: number;
  isExistedId?: boolean;
  isExistedName?: boolean;
}

export interface ComponentInstallState {
  name?: string | undefined;
  isExisted?: boolean;
}

export interface InstallRequestModel {
  uploadFileId?: string | undefined;
  installWay?: InstallWay;
}

export enum InstallWay {
  Merge = 0,
  Wipe = 1,
}

export interface PreviewPackageModel {
  app?: App | undefined;
  standards?: string[] | undefined;
  charts?: string[] | undefined;
  dynamicLists?: string[] | undefined;
  pages?: string[] | undefined;
  locales?: string[] | undefined;
}

export interface Backup extends Entity {
  name?: string | undefined;
  description?: string | undefined;
  creator?: string | undefined;
  fileId?: string | undefined;
  downloadableUrl?: string | undefined;
  backupElements?: BackupElements | undefined;
  encryptShalt?: string | undefined;
  createdDate?: Date;
}

export interface BackupElements {
  apps?: string[] | undefined;
  databases?: string[] | undefined;
  standards?: string[] | undefined;
  tree?: string[] | undefined;
  array?: string[] | undefined;
  charts?: string[] | undefined;
  dynamicLists?: string[] | undefined;
  pages?: string[] | undefined;
  compositeControls?: string[] | undefined;
}

export interface UploadBackupResponseModel {
  id?: string | undefined;
  name?: string | undefined;
  description?: string | undefined;
  creator?: string | undefined;
  createdDate?: Date;
  totalObjects?: number;
  isFileValid?: boolean;
}

export interface BackupResponseModel {
  downloadableUrl?: string | undefined;
}

export interface BackupRequestModel {
  apps?: string[] | undefined;
  databases?: string[] | undefined;
  standards?: string[] | undefined;
  tree?: string[] | undefined;
  array?: string[] | undefined;
  dynamicLists?: string[] | undefined;
  charts?: string[] | undefined;
  pages?: string[] | undefined;
  compositeControls?: string[] | undefined;
  name?: string | undefined;
  description?: string | undefined;
  creator?: string | undefined;
  encryptKey?: string | undefined;
}

export interface PreviewRestoreModel {
  apps?: ComparisonResult[] | undefined;
  standards?: ComparisonResult[] | undefined;
  tree?: ComparisonResult[] | undefined;
  array?: ComparisonResult[] | undefined;
  databases?: ComparisonResult[] | undefined;
  charts?: ComparisonResult[] | undefined;
  dynamicLists?: ComparisonResult[] | undefined;
  pages?: ComparisonResult[] | undefined;
  compositeControls?: ComparisonResult[] | undefined;
  totalObjects?: number;
  totalChangedObjects?: number;
  totalUnchangedObjects?: number;
  totalNewObjects?: number;
}

export interface ComparisonResult {
  result?: ComparisonEntity | undefined;
  isUnchanged?: boolean;
  isTotallyNew?: boolean;
}

export interface ComparisonEntity {
  properties?: ComparisonProperty[] | undefined;
}

export interface ComparisonProperty {
  name?: string | undefined;
  sourceValue?: string | undefined;
  targetValue?: string | undefined;
  comparedState?: ComparedState;
}

export enum ComparedState {
  New = 0,
  Unchanged = 1,
  Changed = 2,
  Deleted = 3,
}

export interface RestoreRequestModel {
  id?: string | undefined;
  requestor?: string | undefined;
}

export interface GenerateCodeRequestModel {
  apps?: string[] | undefined;
  databases?: string[] | undefined;
  standards?: string[] | undefined;
  tree?: string[] | undefined;
  array?: string[] | undefined;
  dynamicLists?: string[] | undefined;
  charts?: string[] | undefined;
  pages?: string[] | undefined;
  compositeControls?: string[] | undefined;
  fileName?: string | undefined;
  versionNumber?: string | undefined;
}

export interface Component extends BackupableEntity {
  datasourceName?: string | undefined;
  appId?: string | undefined;
  options?: ShellOption[] | undefined;
  layoutType?: PageSectionLayoutType;
  allowOverrideOptions?: boolean;
  allowPassingDatasource?: boolean;
}

export interface Chart extends Component {
  definitions?: ChartDefinitions | undefined;
  databaseOptions?: SharedDatabaseOptions | undefined;
  chartFilters?: ChartFilter[] | undefined;
}

export interface ChartDefinitions {
  chartTitle?: string | undefined;
  chartType?: ChartType;
  mappingProjection?: string | undefined;
}

export enum ChartType {
  VerticalBarChart = 0,
  HorizontalBarChart = 1,
  GroupedVerticalBarChart = 2,
  GroupedHorizontalBarChart = 3,
  PieChart = 4,
  AdvancedPieChart = 5,
  PieGrid = 6,
  LineChart = 7,
  AreaChart = 8,
  Gauge = 9,
  NumberCard = 10,
}

export interface SharedDatabaseOptions {
  databaseConnectionId?: string | undefined;
  entityName?: string | undefined;
  query?: string | undefined;
}

export interface ChartFilter {
  name?: string | undefined;
  displayName?: string | undefined;
  type?: FilterType;
  datasourceOptions?: DatasourceOptions | undefined;
  rangeValue?: string | undefined;
  defaultValue?: string | undefined;
  allowDefaultValue?: boolean;
  isMultiple?: boolean;
  isHidden?: boolean;
}

export enum FilterType {
  None = 0,
  Checkbox = 1,
  Select = 2,
  NumberPicker = 3,
  DatePicker = 4,
  MonthYearPicker = 5,
}

export interface DatasourceOptions {
  type?: DatasourceControlType;
  datasourceStaticOptions?: DatasourceStaticOptions | undefined;
  databaseOptions?: SharedDatabaseOptions | undefined;
  httpServiceOptions?: HttpServiceOptions | undefined;
  triggeredEvents?: string | undefined;
}

export enum DatasourceControlType {
  StaticResource = 0,
  Database = 1,
  WebService = 2,
}

export interface DatasourceStaticOptions {
  jsonResource?: string | undefined;
}

export interface HttpServiceOptions {
  httpServiceUrl?: string | undefined;
  httpMethod?: string | undefined;
  httpSuccessCode?: string | undefined;
  jsonBody?: string | undefined;
  outputProjection?: string | undefined;
}

export interface ShellOption {
  key?: string | undefined;
  value?: string | undefined;
  description?: string | undefined;
}

export enum PageSectionLayoutType {
  OneColumn = 0,
  TwoColumns = 1,
  ThreeColumns = 2,
  FourColumns = 3,
  SixColumns = 4,
}

export interface ExtractionChartFilter {
  filters?: ChartFilter[] | undefined;
}

export interface ExtractingChartQueryModel {
  parameters?: FilledParameterModel[] | undefined;
  query?: string | undefined;
  databaseId?: string | undefined;
}

export interface FilledParameterModel {
  name?: string | undefined;
  value?: string | undefined;
}

export interface ExecutionChartResponseModel {
  isSuccess?: boolean;
  result?: any | undefined;
  error?: string | undefined;
}

export interface ExecutionChartRequestModel {
  chartId?: string | undefined;
  isRealTime?: boolean;
  lastRealTimeComparedDate?: Date | undefined;
  realTimeField?: string | undefined;
  chartParameterValues?: ChartParameterValue[] | undefined;
  chartFilterValues?: ChartFilterValue[] | undefined;
}

export interface ChartParameterValue {
  name?: string | undefined;
  value?: string | undefined;
  replaceDQuotes?: boolean;
}

export interface ChartFilterValue {
  name?: string | undefined;
  filterType?: FilterType;
  isMultiple?: boolean;
  value?: string | undefined;
}

export interface CompositeControl extends Entity {
  name?: string | undefined;
  displayName?: string | undefined;
  appId?: string | undefined;
  controls?: PageControl[] | undefined;
}

export interface PageControl {
  id?: string | undefined;
  name?: string | undefined;
  datasourceOptions?: DatasourceOptions | undefined;
  isActive?: boolean;
  order?: number;
  type?: ControlType;
  compositeControlId?: string | undefined;
  validators?: PageControlValidator[] | undefined;
  asyncValidators?: PageControlAsyncValidator[] | undefined;
  options?: ShellOption[] | undefined;
  pageControlEvents?: PageControlEvent[] | undefined;
}

export enum ControlType {
  LineBreaker = 0,
  Label = 1,
  Textbox = 2,
  Textarea = 3,
  Number = 4,
  Email = 5,
  Password = 6,
  DateTime = 7,
  Checkbox = 8,
  Slide = 9,
  Radio = 10,
  Select = 11,
  AutoComplete = 12,
  RichTextEditor = 13,
  Uploader = 14,
  MultiUploader = 15,
  IconPicker = 16,
  MarkdownEditor = 17,
  Composite = 18,
}

export interface PageControlValidator {
  validatorType?: ValidatorType;
  isActive?: boolean;
  validatorOption?: string | undefined;
  validatorMessage?: string | undefined;
}

export enum ValidatorType {
  Required = 0,
  MinLength = 1,
  MaxLength = 2,
  NumberRange = 3,
  Number = 4,
  MinDate = 5,
  MaxDate = 6,
  DateTime = 7,
  Equal = 8,
  EqualTo = 9,
  Regex = 10,
  Email = 11,
  Json = 12,
  FileExtensions = 13,
  FileMaximumSize = 14,
  FileMaximumFiles = 15,
}

export interface PageControlAsyncValidator {
  validatorName?: string | undefined;
  isActive?: boolean;
  validatorMessage?: string | undefined;
  asyncValidatorOptions?: ControlAsyncValidatorOptions | undefined;
}

export interface ControlAsyncValidatorOptions {
  validatorType?: AsyncValidatorType;
  evaluatedExpression?: string | undefined;
  databaseOptions?: SharedDatabaseOptions | undefined;
  httpServiceOptions?: HttpServiceOptions | undefined;
}

export enum AsyncValidatorType {
  DatabaseValidator = 0,
  HttpValidator = 1,
}

export interface PageControlEvent {
  eventName?: string | undefined;
  eventActionType?: EventActionType;
  eventHttpServiceOptions?: EventHttpServiceOptions | undefined;
  eventDatabaseOptions?: EventDatabaseOptions | undefined;
  triggerEventOptions?: TriggerEventOptions | undefined;
}

export enum EventActionType {
  TriggerEvent = 0,
  QueryDatabase = 1,
  WebService = 2,
}

export interface EventHttpServiceOptions extends HttpServiceOptions {
  boundData?: string[] | undefined;
}

export interface EventDatabaseOptions extends SharedDatabaseOptions {
  outputProjection?: string | undefined;
  boundData?: string[] | undefined;
}

export interface TriggerEventOptions {
  eventsList?: string[] | undefined;
}

export interface DatabaseConnection extends BackupableEntity {
  connectionString?: string | undefined;
  dataSource?: string | undefined;
  databaseConnectionType?: string | undefined;
}

export interface ExecuteDynamicResultModel {
  result?: any | undefined;
  isSuccess?: boolean;
  error?: string | undefined;
}

export interface ExtractingSchemaQueryModel {
  columnFields?: ColumnField[] | undefined;
}

export interface ColumnField {
  name?: string | undefined;
  displayName?: string | undefined;
  fieldType?: string | undefined;
}

export interface ExtractionDatabaseRequestModel {
  content?: any | undefined;
  parameters?: ExecuteParamModel[] | undefined;
}

export interface ExecuteParamModel {
  name?: string | undefined;
  replaceValue?: string | undefined;
  removeQuotes?: boolean;
}

export interface DynamicList extends Component {
  listDatasource?: DynamicListDatasource | undefined;
  paramsList?: ParamsList | undefined;
  filtersList?: FiltersList | undefined;
  columnsList?: ColumnsList | undefined;
  commandsList?: CommandsList | undefined;
}

export interface DynamicListDatasource {
  sourceType?: DynamicListSourceType;
  databaseConnectionOptions?: SharedDatabaseOptions | undefined;
  httpServiceOptions?: HttpServiceOptions | undefined;
}

export enum DynamicListSourceType {
  Database = 0,
  HttpService = 1,
}

export interface ParamsList {
  parameters?: Parameter[] | undefined;
}

export interface Parameter {
  name?: string | undefined;
}

export interface FiltersList {
  filterFields?: FilterField[] | undefined;
}

export interface FilterField {
  name?: string | undefined;
  displayName?: string | undefined;
  fieldValueType?: FieldValueType;
  isHidden?: boolean;
  allowTextSearch?: boolean;
  allowInAdvancedMode?: boolean;
}

export enum FieldValueType {
  Text = 0,
  Select = 1,
  Checkbox = 2,
  Slide = 3,
  DatePicker = 4,
  Number = 5,
}

export interface ColumnsList {
  columnDefs?: ColumnDef[] | undefined;
}

export interface ColumnDef {
  id?: string | undefined;
  name?: string | undefined;
  displayName?: string | undefined;
  displayFormat?: string | undefined;
  htmlFunction?: string | undefined;
  displayFormatAsHtml?: boolean;
  allowSort?: boolean;
  searchOptions?: SearchOptions | undefined;
  datasourceOptions?: DynamicListDatasourceOptions | undefined;
  isHidden?: boolean;
  order?: number;
}

export interface SearchOptions {
  fieldValueType?: FieldValueType;
  allowTextSearch?: boolean;
  allowInAdvancedMode?: boolean;
}

export interface DynamicListDatasourceOptions extends DatasourceOptions {
  outputMapProjection?: string | undefined;
}

export interface CommandsList {
  commandButtonsInList?: CommandButtonInList[] | undefined;
}

export interface CommandButtonInList {
  id?: string | undefined;
  name?: string | undefined;
  displayName?: string | undefined;
  icon?: string | undefined;
  color?: string | undefined;
  commandPositionType?: CommandPositionType;
  actionCommandOptions?: ActionCommandOptions | undefined;
  allowRefreshList?: boolean;
  order?: number;
}

export enum CommandPositionType {
  InList = 0,
  OutList = 1,
}

export interface ActionCommandOptions {
  isEnable?: boolean;
  actionType?: ActionType;
  redirectOptions?: RedirectOptions | undefined;
  httpServiceOptions?: HttpServiceOptions | undefined;
  dbExecutionChains?: DatabaseExecutionChains | undefined;
  workflowOptions?: WorkflowOptions | undefined;
  notificationOptions?: NotificationOptions | undefined;
  confirmationOptions?: ConfirmationOptions | undefined;
}

export enum ActionType {
  ExecuteDatabase = 0,
  CallHttpService = 1,
  CallWorkflow = 2,
  Redirect = 3,
}

export interface RedirectOptions {
  redirectUrl?: string | undefined;
  isSameDomain?: boolean;
}

export interface DatabaseExecutionChains {
  steps?: DatabaseExecutionStep[] | undefined;
}

export interface DatabaseExecutionStep {
  dataLoopKey?: string | undefined;
  databaseConnectionId?: string | undefined;
  executeCommand?: string | undefined;
}

export interface WorkflowOptions {
  workflowId?: string | undefined;
  mapWorkflowInputs?: MapWorkflowInput[] | undefined;
}

export interface MapWorkflowInput {
  bindName?: string | undefined;
  bindValue?: string | undefined;
}

export interface NotificationOptions {
  completeMessage?: string | undefined;
  failedMessage?: string | undefined;
}

export interface ConfirmationOptions {
  isEnable?: boolean;
  confirmationText?: string | undefined;
}

export interface DynamicListResponseDataModel {
  data?: any | undefined;
  totalItems?: number;
}

export interface DynamicListFetchDataModel {
  dynamicListId?: string | undefined;
  textSearch?: string | undefined;
  filledParameterOptions?: FilledParameterOptions | undefined;
  filterGroupOptions?: FilterGroupOptions | undefined;
  paginationOptions?: PaginationOptions | undefined;
  sortOptions?: SortOptions | undefined;
}

export interface FilledParameterOptions {
  filledParameters?: FilledParameter[] | undefined;
}

export interface FilledParameter {
  name?: string | undefined;
  value?: string | undefined;
}

export interface FilterGroupOptions {
  filterGroups?: FilterGroup[] | undefined;
}

export interface FilterGroup {
  filterOptions?: FilterOption[] | undefined;
  filterChainOperator?: FilterChainOperator;
}

export interface FilterOption {
  fieldName?: string | undefined;
  filterOperator?: FilterOperator;
  fieldValue?: any | undefined;
  filterValueType?: FieldValueType;
  filterChainOperator?: FilterChainOperator;
}

export enum FilterOperator {
  Equal = 0,
  Contains = 1,
  Lesser = 2,
  Greater = 3,
  Less = 4,
  Great = 5,
}

export enum FilterChainOperator {
  None = 0,
  And = 1,
  Or = 2,
}

export interface PaginationOptions {
  pageNumber?: number;
  pageSize?: number;
  needTotalItems?: boolean;
}

export interface SortOptions {
  sortableFields?: SortableField[] | undefined;
}

export interface SortableField {
  fieldName?: string | undefined;
  sortType?: SortType;
}

export enum SortType {
  Asc = 0,
  Desc = 1,
}

export interface PopulateQueryModel {
  columnFields?: ColumnField[] | undefined;
}

export interface ExtractingQueryModel {
  parameters?: FilledParameterModel2[] | undefined;
  query?: string | undefined;
  databaseId?: string | undefined;
}

export interface FilledParameterModel2 {
  name?: string | undefined;
  value?: string | undefined;
}

export interface EntitySchema extends Entity {
  name?: string | undefined;
  displayName?: string | undefined;
  timeSpan?: number;
  databaseId?: string | undefined;
  appId?: string | undefined;
  entityFields?: EntityField[] | undefined;
}

export interface EntityField {
  name?: string | undefined;
  displayName?: string | undefined;
  fieldType?: string | undefined;
}

export interface FlushDatabaseModel {
  databaseId?: string | undefined;
  keptSameName?: boolean;
}

export interface ResponseUploadFile {
  fileId?: string | undefined;
  downloadVirtualPath?: string | undefined;
}

export interface File extends Entity {
  name?: string | undefined;
  uploader?: string | undefined;
  downloadVirtualPath?: string | undefined;
  identifierOptions?: string | undefined;
  mimeType?: string | undefined;
  fileSize?: number;
  allowCompress?: boolean;
  fileStorageType?: FileStorageType;
  dateUploaded?: Date;
}

export enum FileStorageType {
  Disk = 0,
  Database = 1,
}

export interface Localization extends Entity {
  localizationContents?: LocalizationContent[] | undefined;
  localeId?: string | undefined;
  appId?: string | undefined;
}

export interface LocalizationContent extends Entity {
  key?: string | undefined;
  text?: string | undefined;
  localizationId?: string | undefined;
  localization?: Localization | undefined;
}

export interface LanguageKey {
  key?: string | undefined;
  value?: string | undefined;
}

export interface ShortPageModel {
  id?: string | undefined;
  name?: string | undefined;
  displayName?: string | undefined;
  urlPath?: string | undefined;
}

export interface ShortPortalClaimModel {
  pageName?: string | undefined;
  pageDisplayName?: string | undefined;
  claims?: PortalClaim[] | undefined;
}

export interface PortalClaim {
  name?: string | undefined;
  displayName?: string | undefined;
  claimValueType?: ClaimValueType;
}

export enum ClaimValueType {
  Boolean = 0,
  String = 1,
  Number = 2,
  Array = 3,
}

export interface Page extends BackupableEntity {
  urlPath?: string | undefined;
  appId?: string | undefined;
  shellOptions?: ShellOption[] | undefined;
  claims?: PortalClaim[] | undefined;
  builder?: PageBuilder | undefined;
  pageDatasources?: PageDatasource[] | undefined;
  events?: PageEvent[] | undefined;
  commands?: PageButton[] | undefined;
}

export interface PageBuilder {
  sections?: PageSection[] | undefined;
}

export interface PageSection {
  id?: string | undefined;
  name?: string | undefined;
  displayName?: string | undefined;
  constructionType?: SectionContructionType;
  overrideOptions?: ShellOption[] | undefined;
  sectionDatasource?: SectionDatasource | undefined;
  componentId?: string | undefined;
  hidden?: string | undefined;
  rendered?: string | undefined;
  order?: number;
}

export enum SectionContructionType {
  Standard = 0,
  Array = 1,
  DynamicList = 2,
  Chart = 3,
  Tree = 4,
}

export interface SectionDatasource {
  datasourceBindName?: string | undefined;
  dataStoreName?: string | undefined;
}

export interface PageDatasource {
  id?: string | undefined;
  name?: string | undefined;
  triggerCondition?: string | undefined;
  isActive?: boolean;
  options?: DatasourceOptions | undefined;
}

export interface PageEvent {
  eventName?: string | undefined;
  eventActionType?: EventActionType;
  httpServiceOptions?: EventHttpServiceOptions | undefined;
  triggerEventOptions?: TriggerEventOptions | undefined;
}

export interface PageButton {
  id?: string | undefined;
  name?: string | undefined;
  icon?: string | undefined;
  color?: string | undefined;
  isRequiredValidation?: boolean;
  allowHidden?: string | undefined;
  placeSectionId?: string | undefined;
  buttonOptions?: ButtonOptions | undefined;
}

export interface ButtonOptions {
  actionCommandOptions?: ActionCommandOptions | undefined;
  routeOptions?: RouteOptions | undefined;
}

export interface RouteOptions {
  routes?: Route[] | undefined;
  isEnable?: boolean;
}

export interface Route {
  redirectUrl?: string | undefined;
  isSameDomain?: boolean;
  condition?: string | undefined;
}

export interface PageSubmittedButtonModel {
  buttonName?: string | undefined;
  parameters?: PageParameterModel[] | undefined;
  loopDatas?: LoopDataModel[] | undefined;
}

export interface PageParameterModel {
  name?: string | undefined;
  replaceValue?: string | undefined;
  removeQuotes?: boolean;
}

export interface LoopDataModel {
  name?: string | undefined;
  parameters?: PageParameterModel[][] | undefined;
}

export interface PageSelectionDatasourceModel {
  sectionName?: string | undefined;
  controlName?: string | undefined;
  compositeControlId?: string | undefined;
  isChildCompositeControl?: boolean;
  parameters?: PageParameterModel[] | undefined;
}

export interface PageTriggeringEventModel {
  sectionName?: string | undefined;
  controlName?: string | undefined;
  eventName?: string | undefined;
  parameters?: PageParameterModel[] | undefined;
}

export interface PageAsyncValidatorModel {
  sectionName?: string | undefined;
  controlName?: string | undefined;
  asyncName?: string | undefined;
  parameters?: PageParameterModel[] | undefined;
}

export interface PageRequestDatasourceModel {
  datasourceId?: string | undefined;
  parameters?: PageParameterModel[] | undefined;
}

export interface StandardComponent extends Component {
  type?: StandardType;
  controls?: PageControl[] | undefined;
}

export enum StandardType {
  Standard = 0,
  Array = 1,
  Tree = 2,
}

export interface FileParameter {
  data: any;
  fileName: string;
}

export interface FileResponse {
  data: Blob;
  status: number;
  fileName?: string;
  headers?: { [name: string]: any };
}

export class ApiException extends Error {
  override message: string;
  status: number;
  response: string;
  headers: { [key: string]: any; };
  result: any;

  constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
    super();

    this.message = message;
    this.status = status;
    this.response = response;
    this.headers = headers;
    this.result = result;
  }

  protected isApiException = true;

  static isApiException(obj: any): obj is ApiException {
    return obj.isApiException === true;
  }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
  if (result !== null && result !== undefined)
    return _observableThrow(result);
  else
    return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
  return new Observable<string>((observer: any) => {
    if (!blob) {
      observer.next("");
      observer.complete();
    } else {
      let reader = new FileReader();
      reader.onload = event => {
        observer.next((event.target as any).result);
        observer.complete();
      };
      reader.readAsText(blob);
    }
  });
}
