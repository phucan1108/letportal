/* tslint:disable */
/* eslint-disable */
//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v13.9.4.0 (NJsonSchema v10.3.1.0 (Newtonsoft.Json v12.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------
// ReSharper disable InconsistentNaming

import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';
import { Inject, Injectable, InjectionToken, Optional } from '@angular/core';
import { Observable, of as _observableOf, throwError as _observableThrow } from 'rxjs';
import { catchError as _observableCatch, mergeMap as _observableMergeMap } from 'rxjs/operators';

export const PORTAL_BASE_URL = new InjectionToken<string>('PORTAL_BASE_URL');

export interface IChatsClient {
    getAllOnlineUser(): Observable<FileResponse>;
    getAllChatUsers(): Observable<OnlineUser[]>;
    online(): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ChatsClient implements IChatsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getAllOnlineUser(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/chats/who-online";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllOnlineUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllOnlineUser(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllOnlineUser(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getAllChatUsers(): Observable<OnlineUser[]> {
        let url_ = this.baseUrl + "/api/chats/all-users";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllChatUsers(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllChatUsers(<any>response_);
                } catch (e) {
                    return <Observable<OnlineUser[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<OnlineUser[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllChatUsers(response: HttpResponseBase): Observable<OnlineUser[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <OnlineUser[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<OnlineUser[]>(<any>null);
    }

    online(): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/chats/online";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processOnline(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processOnline(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processOnline(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IAppsClient {
    getOne(id: string | null, localeId: string | null): Observable<App>;
    getAll(): Observable<App[]>;
    getMany(localeId: string | null, ids: string | null | undefined): Observable<App[]>;
    getShortApps(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
    getAvailableUrls(id: string | null): Observable<AvailableUrl[]>;
    create(app: App): Observable<App>;
    getAllApps(localeId: string | null | undefined): Observable<App[]>;
    update(id: string | null, app: App): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
    updateMenu(id: string | null, menus: Menu[]): Observable<FileResponse>;
    asssignRolesToMenu(id: string | null, menuProfile: MenuProfile): Observable<FileResponse>;
    clone(model: CloneModel): Observable<FileResponse>;
    package(appId: string | null, model: PackageRequestModel): Observable<PackageResponseModel>;
    unpack(formFile: FileParameter | null | undefined): Observable<UnpackResponseModel>;
    install(model: InstallRequestModel): Observable<FileResponse>;
    preview(appId: string | null): Observable<PreviewPackageModel>;
}

@Injectable({
    providedIn: 'root'
})
export class AppsClient implements IAppsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getOne(id: string | null, localeId: string | null): Observable<App> {
        let url_ = this.baseUrl + "/api/apps/{id}/{localeId}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<App>><any>_observableThrow(e);
                }
            } else
                return <Observable<App>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<App> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<App>(<any>null);
    }

    getAll(): Observable<App[]> {
        let url_ = this.baseUrl + "/api/apps/all-apps";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<App[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<App[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<App[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<App[]>(<any>null);
    }

    getMany(localeId: string | null, ids: string | null | undefined): Observable<App[]> {
        let url_ = this.baseUrl + "/api/apps/all/{localeId}?";
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        if (ids !== undefined && ids !== null)
            url_ += "ids=" + encodeURIComponent("" + ids) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<App[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<App[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<App[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<App[]>(<any>null);
    }

    getShortApps(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/apps/short-apps?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortApps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortApps(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShortApps(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }

    getAvailableUrls(id: string | null): Observable<AvailableUrl[]> {
        let url_ = this.baseUrl + "/api/apps/{id}/urls";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAvailableUrls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAvailableUrls(<any>response_);
                } catch (e) {
                    return <Observable<AvailableUrl[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<AvailableUrl[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAvailableUrls(response: HttpResponseBase): Observable<AvailableUrl[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <AvailableUrl[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<AvailableUrl[]>(<any>null);
    }

    create(app: App): Observable<App> {
        let url_ = this.baseUrl + "/api/apps";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(app);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<App>><any>_observableThrow(e);
                }
            } else
                return <Observable<App>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<App> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<App>(<any>null);
    }

    getAllApps(localeId: string | null | undefined): Observable<App[]> {
        let url_ = this.baseUrl + "/api/apps?";
        if (localeId !== undefined && localeId !== null)
            url_ += "localeId=" + encodeURIComponent("" + localeId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllApps(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllApps(<any>response_);
                } catch (e) {
                    return <Observable<App[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<App[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllApps(response: HttpResponseBase): Observable<App[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <App[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<App[]>(<any>null);
    }

    update(id: string | null, app: App): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/apps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(app);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/apps/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    updateMenu(id: string | null, menus: Menu[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/apps/{id}/menus";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(menus);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateMenu(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateMenu(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    asssignRolesToMenu(id: string | null, menuProfile: MenuProfile): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/apps/{id}/menus/assign-role";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(menuProfile);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAsssignRolesToMenu(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAsssignRolesToMenu(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processAsssignRolesToMenu(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    clone(model: CloneModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/apps/clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClone(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClone(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    package(appId: string | null, model: PackageRequestModel): Observable<PackageResponseModel> {
        let url_ = this.baseUrl + "/api/apps/{appId}/package";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPackage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPackage(<any>response_);
                } catch (e) {
                    return <Observable<PackageResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PackageResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processPackage(response: HttpResponseBase): Observable<PackageResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PackageResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PackageResponseModel>(<any>null);
    }

    unpack(formFile: FileParameter | null | undefined): Observable<UnpackResponseModel> {
        let url_ = this.baseUrl + "/api/apps/unpackage";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUnpack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUnpack(<any>response_);
                } catch (e) {
                    return <Observable<UnpackResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UnpackResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUnpack(response: HttpResponseBase): Observable<UnpackResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UnpackResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UnpackResponseModel>(<any>null);
    }

    install(model: InstallRequestModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/apps/install";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processInstall(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processInstall(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processInstall(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    preview(appId: string | null): Observable<PreviewPackageModel> {
        let url_ = this.baseUrl + "/api/apps/{appId}/preview";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreview(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreview(<any>response_);
                } catch (e) {
                    return <Observable<PreviewPackageModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PreviewPackageModel>><any>_observableThrow(response_);
        }));
    }

    protected processPreview(response: HttpResponseBase): Observable<PreviewPackageModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PreviewPackageModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreviewPackageModel>(<any>null);
    }
}

export interface IBackupsClient {
    getOne(id: string | null): Observable<Backup>;
    uploadBackupFile(formFile: FileParameter | null | undefined): Observable<UploadBackupResponseModel>;
    create(model: BackupRequestModel): Observable<BackupResponseModel>;
    previewBackup(id: string | null): Observable<PreviewRestoreModel>;
    restoreBackup(id: string, model: RestoreRequestModel): Observable<FileResponse>;
    generateCode(model: GenerateCodeRequestModel): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class BackupsClient implements IBackupsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getOne(id: string | null): Observable<Backup> {
        let url_ = this.baseUrl + "/api/backups/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<Backup>><any>_observableThrow(e);
                }
            } else
                return <Observable<Backup>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<Backup> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Backup>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Backup>(<any>null);
    }

    uploadBackupFile(formFile: FileParameter | null | undefined): Observable<UploadBackupResponseModel> {
        let url_ = this.baseUrl + "/api/backups/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUploadBackupFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUploadBackupFile(<any>response_);
                } catch (e) {
                    return <Observable<UploadBackupResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<UploadBackupResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processUploadBackupFile(response: HttpResponseBase): Observable<UploadBackupResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <UploadBackupResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<UploadBackupResponseModel>(<any>null);
    }

    create(model: BackupRequestModel): Observable<BackupResponseModel> {
        let url_ = this.baseUrl + "/api/backups";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<BackupResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<BackupResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<BackupResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <BackupResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<BackupResponseModel>(<any>null);
    }

    previewBackup(id: string | null): Observable<PreviewRestoreModel> {
        let url_ = this.baseUrl + "/api/backups/{id}/preview";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPreviewBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPreviewBackup(<any>response_);
                } catch (e) {
                    return <Observable<PreviewRestoreModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PreviewRestoreModel>><any>_observableThrow(response_);
        }));
    }

    protected processPreviewBackup(response: HttpResponseBase): Observable<PreviewRestoreModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PreviewRestoreModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PreviewRestoreModel>(<any>null);
    }

    restoreBackup(id: string, model: RestoreRequestModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/backups/{id}/restore";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRestoreBackup(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRestoreBackup(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processRestoreBackup(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    generateCode(model: GenerateCodeRequestModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/backups/generate-code";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateCode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateCode(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateCode(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IChartsClient {
    getMany(): Observable<Chart[]>;
    create(chart: Chart): Observable<Chart>;
    getOne(id: string | null): Observable<Chart>;
    update(id: string | null, chart: Chart): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
    getOneForBuilder(id: string | null): Observable<Chart>;
    getShortCharts(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
    checkExist(name: string | null): Observable<boolean>;
    extraction(model: ExtractingChartQueryModel): Observable<ExtractionChartFilter>;
    execution(model: ExecutionChartRequestModel): Observable<ExecutionChartResponseModel>;
    clone(model: CloneModel): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ChartsClient implements IChartsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getMany(): Observable<Chart[]> {
        let url_ = this.baseUrl + "/api/charts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetMany(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetMany(<any>response_);
                } catch (e) {
                    return <Observable<Chart[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chart[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetMany(response: HttpResponseBase): Observable<Chart[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Chart[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chart[]>(<any>null);
    }

    create(chart: Chart): Observable<Chart> {
        let url_ = this.baseUrl + "/api/charts";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chart);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<Chart>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chart>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<Chart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Chart>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chart>(<any>null);
    }

    getOne(id: string | null): Observable<Chart> {
        let url_ = this.baseUrl + "/api/charts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<Chart>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chart>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<Chart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Chart>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chart>(<any>null);
    }

    update(id: string | null, chart: Chart): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/charts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(chart);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/charts/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOneForBuilder(id: string | null): Observable<Chart> {
        let url_ = this.baseUrl + "/api/charts/{id}/builder";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneForBuilder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneForBuilder(<any>response_);
                } catch (e) {
                    return <Observable<Chart>><any>_observableThrow(e);
                }
            } else
                return <Observable<Chart>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneForBuilder(response: HttpResponseBase): Observable<Chart> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Chart>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Chart>(<any>null);
    }

    getShortCharts(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/charts/short-charts?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortCharts(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortCharts(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShortCharts(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }

    checkExist(name: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/charts/check-exist/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    extraction(model: ExtractingChartQueryModel): Observable<ExtractionChartFilter> {
        let url_ = this.baseUrl + "/api/charts/extract";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtraction(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtraction(<any>response_);
                } catch (e) {
                    return <Observable<ExtractionChartFilter>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExtractionChartFilter>><any>_observableThrow(response_);
        }));
    }

    protected processExtraction(response: HttpResponseBase): Observable<ExtractionChartFilter> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExtractionChartFilter>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtractionChartFilter>(<any>null);
    }

    execution(model: ExecutionChartRequestModel): Observable<ExecutionChartResponseModel> {
        let url_ = this.baseUrl + "/api/charts/execution";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecution(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecution(<any>response_);
                } catch (e) {
                    return <Observable<ExecutionChartResponseModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExecutionChartResponseModel>><any>_observableThrow(response_);
        }));
    }

    protected processExecution(response: HttpResponseBase): Observable<ExecutionChartResponseModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExecutionChartResponseModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExecutionChartResponseModel>(<any>null);
    }

    clone(model: CloneModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/charts/clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClone(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClone(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ICompositeControlsClient {
    get(id: string | null): Observable<CompositeControl>;
    update(id: string | null, model: CompositeControl): Observable<FileResponse>;
    getAll(ids: string | null | undefined): Observable<CompositeControl[]>;
    create(model: CompositeControl): Observable<FileResponse>;
    getShortControls(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
}

@Injectable({
    providedIn: 'root'
})
export class CompositeControlsClient implements ICompositeControlsClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    get(id: string | null): Observable<CompositeControl> {
        let url_ = this.baseUrl + "/api/composite-controls/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<CompositeControl>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompositeControl>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<CompositeControl> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompositeControl>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompositeControl>(<any>null);
    }

    update(id: string | null, model: CompositeControl): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/composite-controls/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getAll(ids: string | null | undefined): Observable<CompositeControl[]> {
        let url_ = this.baseUrl + "/api/composite-controls?";
        if (ids !== undefined && ids !== null)
            url_ += "ids=" + encodeURIComponent("" + ids) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<CompositeControl[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<CompositeControl[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<CompositeControl[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <CompositeControl[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<CompositeControl[]>(<any>null);
    }

    create(model: CompositeControl): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/composite-controls";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getShortControls(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/composite-controls/short-controls?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortControls(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortControls(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShortControls(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }
}

export interface IDatabasesClient {
    getAll(): Observable<DatabaseConnection[]>;
    post(databaseConnection: DatabaseConnection): Observable<DatabaseConnection>;
    get(id: string | null): Observable<DatabaseConnection>;
    put(id: string | null, databaseConnection: DatabaseConnection): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
    getShortDatabases(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
    executionDynamic(databaseId: string | null, content: any): Observable<ExecuteDynamicResultModel>;
    extractingQuery(databaseId: string | null, model: ExtractionDatabaseRequestModel): Observable<ExtractingSchemaQueryModel>;
    executeQueryDatasource(databaseId: string | null, content: any): Observable<ExecuteDynamicResultModel>;
    clone(model: CloneModel): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class DatabasesClient implements IDatabasesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getAll(): Observable<DatabaseConnection[]> {
        let url_ = this.baseUrl + "/api/databases";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DatabaseConnection[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatabaseConnection[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DatabaseConnection[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DatabaseConnection[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatabaseConnection[]>(<any>null);
    }

    post(databaseConnection: DatabaseConnection): Observable<DatabaseConnection> {
        let url_ = this.baseUrl + "/api/databases";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(databaseConnection);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPost(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPost(<any>response_);
                } catch (e) {
                    return <Observable<DatabaseConnection>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatabaseConnection>><any>_observableThrow(response_);
        }));
    }

    protected processPost(response: HttpResponseBase): Observable<DatabaseConnection> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DatabaseConnection>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatabaseConnection>(<any>null);
    }

    get(id: string | null): Observable<DatabaseConnection> {
        let url_ = this.baseUrl + "/api/databases/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<DatabaseConnection>><any>_observableThrow(e);
                }
            } else
                return <Observable<DatabaseConnection>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<DatabaseConnection> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DatabaseConnection>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DatabaseConnection>(<any>null);
    }

    put(id: string | null, databaseConnection: DatabaseConnection): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/databases/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(databaseConnection);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processPut(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processPut(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processPut(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/databases/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getShortDatabases(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/databases/short-databases?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortDatabases(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortDatabases(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShortDatabases(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }

    executionDynamic(databaseId: string | null, content: any): Observable<ExecuteDynamicResultModel> {
        let url_ = this.baseUrl + "/api/databases/{databaseId}/execution";
        if (databaseId === undefined || databaseId === null)
            throw new Error("The parameter 'databaseId' must be defined.");
        url_ = url_.replace("{databaseId}", encodeURIComponent("" + databaseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecutionDynamic(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecutionDynamic(<any>response_);
                } catch (e) {
                    return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExecutionDynamic(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExecuteDynamicResultModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExecuteDynamicResultModel>(<any>null);
    }

    extractingQuery(databaseId: string | null, model: ExtractionDatabaseRequestModel): Observable<ExtractingSchemaQueryModel> {
        let url_ = this.baseUrl + "/api/databases/{databaseId}/extract-raw";
        if (databaseId === undefined || databaseId === null)
            throw new Error("The parameter 'databaseId' must be defined.");
        url_ = url_.replace("{databaseId}", encodeURIComponent("" + databaseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtractingQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtractingQuery(<any>response_);
                } catch (e) {
                    return <Observable<ExtractingSchemaQueryModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExtractingSchemaQueryModel>><any>_observableThrow(response_);
        }));
    }

    protected processExtractingQuery(response: HttpResponseBase): Observable<ExtractingSchemaQueryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExtractingSchemaQueryModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExtractingSchemaQueryModel>(<any>null);
    }

    executeQueryDatasource(databaseId: string | null, content: any): Observable<ExecuteDynamicResultModel> {
        let url_ = this.baseUrl + "/api/databases/{databaseId}/query-datasource";
        if (databaseId === undefined || databaseId === null)
            throw new Error("The parameter 'databaseId' must be defined.");
        url_ = url_.replace("{databaseId}", encodeURIComponent("" + databaseId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(content);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteQueryDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteQueryDatasource(<any>response_);
                } catch (e) {
                    return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExecuteQueryDatasource(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExecuteDynamicResultModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExecuteDynamicResultModel>(<any>null);
    }

    clone(model: CloneModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/databases/clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClone(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClone(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IDynamicListClient {
    getAll(): Observable<DynamicList[]>;
    create(dynamicList: DynamicList): Observable<DynamicList>;
    getOne(id: string | null): Observable<DynamicList>;
    update(id: string | null, dynamicList: DynamicList): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
    getOneForRender(id: string | null): Observable<DynamicList>;
    getShortDynamicLists(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
    executeQuery(id: string | null, fetchDataModel: DynamicListFetchDataModel): Observable<DynamicListResponseDataModel>;
    extractingQuery(extractingQuery: ExtractingQueryModel): Observable<PopulateQueryModel>;
    checkExist(name: string | null): Observable<boolean>;
    clone(model: CloneModel): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class DynamicListClient implements IDynamicListClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getAll(): Observable<DynamicList[]> {
        let url_ = this.baseUrl + "/api/dynamiclists";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(<any>response_);
                } catch (e) {
                    return <Observable<DynamicList[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicList[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<DynamicList[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DynamicList[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicList[]>(<any>null);
    }

    create(dynamicList: DynamicList): Observable<DynamicList> {
        let url_ = this.baseUrl + "/api/dynamiclists";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dynamicList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<DynamicList>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicList>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<DynamicList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DynamicList>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicList>(<any>null);
    }

    getOne(id: string | null): Observable<DynamicList> {
        let url_ = this.baseUrl + "/api/dynamiclists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<DynamicList>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicList>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<DynamicList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DynamicList>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicList>(<any>null);
    }

    update(id: string | null, dynamicList: DynamicList): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/dynamiclists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(dynamicList);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/dynamiclists/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOneForRender(id: string | null): Observable<DynamicList> {
        let url_ = this.baseUrl + "/api/dynamiclists/{id}/render";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneForRender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneForRender(<any>response_);
                } catch (e) {
                    return <Observable<DynamicList>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicList>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneForRender(response: HttpResponseBase): Observable<DynamicList> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DynamicList>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicList>(<any>null);
    }

    getShortDynamicLists(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/dynamiclists/short-dynamiclists?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortDynamicLists(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortDynamicLists(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShortDynamicLists(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }

    executeQuery(id: string | null, fetchDataModel: DynamicListFetchDataModel): Observable<DynamicListResponseDataModel> {
        let url_ = this.baseUrl + "/api/dynamiclists/{id}/fetch-data";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(fetchDataModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteQuery(<any>response_);
                } catch (e) {
                    return <Observable<DynamicListResponseDataModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<DynamicListResponseDataModel>><any>_observableThrow(response_);
        }));
    }

    protected processExecuteQuery(response: HttpResponseBase): Observable<DynamicListResponseDataModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <DynamicListResponseDataModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<DynamicListResponseDataModel>(<any>null);
    }

    extractingQuery(extractingQuery: ExtractingQueryModel): Observable<PopulateQueryModel> {
        let url_ = this.baseUrl + "/api/dynamiclists/extract-query";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(extractingQuery);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExtractingQuery(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExtractingQuery(<any>response_);
                } catch (e) {
                    return <Observable<PopulateQueryModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<PopulateQueryModel>><any>_observableThrow(response_);
        }));
    }

    protected processExtractingQuery(response: HttpResponseBase): Observable<PopulateQueryModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <PopulateQueryModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<PopulateQueryModel>(<any>null);
    }

    checkExist(name: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/dynamiclists/check-exist/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    clone(model: CloneModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/dynamiclists/clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClone(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClone(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IEntitySchemasClient {
    getOne(databaseId: string | null, entityName: string | null): Observable<EntitySchema>;
    fetchAllFromDatabase(id: string | null): Observable<EntitySchema[]>;
    getAllFromOneDatabase(id: string | null): Observable<EntitySchema[]>;
    flushOneDatabase(flushDatabaseModel: FlushDatabaseModel): Observable<EntitySchema[]>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class EntitySchemasClient implements IEntitySchemasClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getOne(databaseId: string | null, entityName: string | null): Observable<EntitySchema> {
        let url_ = this.baseUrl + "/api/entity-schemas/{entityName}/{databaseId}";
        if (databaseId === undefined || databaseId === null)
            throw new Error("The parameter 'databaseId' must be defined.");
        url_ = url_.replace("{databaseId}", encodeURIComponent("" + databaseId));
        if (entityName === undefined || entityName === null)
            throw new Error("The parameter 'entityName' must be defined.");
        url_ = url_.replace("{entityName}", encodeURIComponent("" + entityName));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<EntitySchema>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntitySchema>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<EntitySchema> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EntitySchema>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntitySchema>(<any>null);
    }

    fetchAllFromDatabase(id: string | null): Observable<EntitySchema[]> {
        let url_ = this.baseUrl + "/api/entity-schemas/fetch/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchAllFromDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchAllFromDatabase(<any>response_);
                } catch (e) {
                    return <Observable<EntitySchema[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntitySchema[]>><any>_observableThrow(response_);
        }));
    }

    protected processFetchAllFromDatabase(response: HttpResponseBase): Observable<EntitySchema[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EntitySchema[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntitySchema[]>(<any>null);
    }

    getAllFromOneDatabase(id: string | null): Observable<EntitySchema[]> {
        let url_ = this.baseUrl + "/api/entity-schemas/database/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllFromOneDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllFromOneDatabase(<any>response_);
                } catch (e) {
                    return <Observable<EntitySchema[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntitySchema[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllFromOneDatabase(response: HttpResponseBase): Observable<EntitySchema[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EntitySchema[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntitySchema[]>(<any>null);
    }

    flushOneDatabase(flushDatabaseModel: FlushDatabaseModel): Observable<EntitySchema[]> {
        let url_ = this.baseUrl + "/api/entity-schemas/flush";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(flushDatabaseModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFlushOneDatabase(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFlushOneDatabase(<any>response_);
                } catch (e) {
                    return <Observable<EntitySchema[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<EntitySchema[]>><any>_observableThrow(response_);
        }));
    }

    protected processFlushOneDatabase(response: HttpResponseBase): Observable<EntitySchema[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <EntitySchema[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<EntitySchema[]>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/entity-schemas/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IFilesClient {
    upload(formFile: FileParameter | null | undefined): Observable<ResponseUploadFile>;
    getFileInfo(fileId: string | null): Observable<File>;
    getFile(fileId: string | null, compress: boolean | null | undefined): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class FilesClient implements IFilesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    upload(formFile: FileParameter | null | undefined): Observable<ResponseUploadFile> {
        let url_ = this.baseUrl + "/api/files/upload";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (formFile !== null && formFile !== undefined)
            content_.append("formFile", formFile.data, formFile.fileName ? formFile.fileName : "formFile");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpload(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpload(<any>response_);
                } catch (e) {
                    return <Observable<ResponseUploadFile>><any>_observableThrow(e);
                }
            } else
                return <Observable<ResponseUploadFile>><any>_observableThrow(response_);
        }));
    }

    protected processUpload(response: HttpResponseBase): Observable<ResponseUploadFile> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ResponseUploadFile>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ResponseUploadFile>(<any>null);
    }

    getFileInfo(fileId: string | null): Observable<File> {
        let url_ = this.baseUrl + "/api/files/metadata/{fileId}";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFileInfo(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFileInfo(<any>response_);
                } catch (e) {
                    return <Observable<File>><any>_observableThrow(e);
                }
            } else
                return <Observable<File>><any>_observableThrow(response_);
        }));
    }

    protected processGetFileInfo(response: HttpResponseBase): Observable<File> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <File>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<File>(<any>null);
    }

    getFile(fileId: string | null, compress: boolean | null | undefined): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/files/download/{fileId}?";
        if (fileId === undefined || fileId === null)
            throw new Error("The parameter 'fileId' must be defined.");
        url_ = url_.replace("{fileId}", encodeURIComponent("" + fileId));
        if (compress !== undefined && compress !== null)
            url_ += "compress=" + encodeURIComponent("" + compress) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFile(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFile(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGetFile(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface ILocalizationClient {
    getOne(appId: string | null, localeId: string | null): Observable<Localization>;
    checkExist(appId: string | null, localeId: string | null): Observable<Localization>;
    collectAll(appId: string | null): Observable<LanguageKey[]>;
    create(localization: Localization): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class LocalizationClient implements ILocalizationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getOne(appId: string | null, localeId: string | null): Observable<Localization> {
        let url_ = this.baseUrl + "/api/localizations/{appId}/{localeId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<Localization>><any>_observableThrow(e);
                }
            } else
                return <Observable<Localization>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<Localization> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Localization>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Localization>(<any>null);
    }

    checkExist(appId: string | null, localeId: string | null): Observable<Localization> {
        let url_ = this.baseUrl + "/api/localizations/exist/{appId}/{localeId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        if (localeId === undefined || localeId === null)
            throw new Error("The parameter 'localeId' must be defined.");
        url_ = url_.replace("{localeId}", encodeURIComponent("" + localeId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<Localization>><any>_observableThrow(e);
                }
            } else
                return <Observable<Localization>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<Localization> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Localization>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Localization>(<any>null);
    }

    collectAll(appId: string | null): Observable<LanguageKey[]> {
        let url_ = this.baseUrl + "/api/localizations/collectAll/{appId}";
        if (appId === undefined || appId === null)
            throw new Error("The parameter 'appId' must be defined.");
        url_ = url_.replace("{appId}", encodeURIComponent("" + appId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCollectAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCollectAll(<any>response_);
                } catch (e) {
                    return <Observable<LanguageKey[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LanguageKey[]>><any>_observableThrow(response_);
        }));
    }

    protected processCollectAll(response: HttpResponseBase): Observable<LanguageKey[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LanguageKey[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LanguageKey[]>(<any>null);
    }

    create(localization: Localization): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/localizations";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(localization);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/localizations/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IPagesClient {
    getAllShortPages(): Observable<ShortPageModel[]>;
    getAllPortalClaims(): Observable<ShortPortalClaimModel[]>;
    getOneById(id: string | null): Observable<Page>;
    getOne(name: string | null): Observable<Page>;
    getOneForRender(name: string | null): Observable<Page>;
    getShortPages(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
    create(page: Page): Observable<string>;
    update(id: string | null, page: Page): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
    checkExist(name: string | null): Observable<boolean>;
    submitCommand(pageId: string | null, pageSubmittedButtonModel: PageSubmittedButtonModel): Observable<ExecuteDynamicResultModel>;
    fetchControlDatasource(pageId: string | null, model: PageSelectionDatasourceModel): Observable<ExecuteDynamicResultModel>;
    executeTriggeredEvent(pageId: string | null, model: PageTriggeringEventModel): Observable<ExecuteDynamicResultModel>;
    executeAsyncValidator(pageId: string | null, validatorModel: PageAsyncValidatorModel): Observable<ExecuteDynamicResultModel>;
    getDatasourceForPage(pageId: string | null, pageRequestDatasourceModel: PageRequestDatasourceModel): Observable<ExecuteDynamicResultModel>;
    clone(model: CloneModel): Observable<FileResponse>;
    generateLanguages(id: string | null): Observable<LanguageKey[]>;
}

@Injectable({
    providedIn: 'root'
})
export class PagesClient implements IPagesClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getAllShortPages(): Observable<ShortPageModel[]> {
        let url_ = this.baseUrl + "/api/pages/shorts";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllShortPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllShortPages(<any>response_);
                } catch (e) {
                    return <Observable<ShortPageModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortPageModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllShortPages(response: HttpResponseBase): Observable<ShortPageModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortPageModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortPageModel[]>(<any>null);
    }

    getAllPortalClaims(): Observable<ShortPortalClaimModel[]> {
        let url_ = this.baseUrl + "/api/pages/all-claims";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAllPortalClaims(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAllPortalClaims(<any>response_);
                } catch (e) {
                    return <Observable<ShortPortalClaimModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortPortalClaimModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetAllPortalClaims(response: HttpResponseBase): Observable<ShortPortalClaimModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortPortalClaimModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortPortalClaimModel[]>(<any>null);
    }

    getOneById(id: string | null): Observable<Page> {
        let url_ = this.baseUrl + "/api/pages/get-by-id/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneById(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneById(<any>response_);
                } catch (e) {
                    return <Observable<Page>><any>_observableThrow(e);
                }
            } else
                return <Observable<Page>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneById(response: HttpResponseBase): Observable<Page> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Page>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Page>(<any>null);
    }

    getOne(name: string | null): Observable<Page> {
        let url_ = this.baseUrl + "/api/pages/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<Page>><any>_observableThrow(e);
                }
            } else
                return <Observable<Page>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<Page> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Page>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Page>(<any>null);
    }

    getOneForRender(name: string | null): Observable<Page> {
        let url_ = this.baseUrl + "/api/pages/render/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneForRender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneForRender(<any>response_);
                } catch (e) {
                    return <Observable<Page>><any>_observableThrow(e);
                }
            } else
                return <Observable<Page>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneForRender(response: HttpResponseBase): Observable<Page> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <Page>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<Page>(<any>null);
    }

    getShortPages(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/pages/short-pages?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetShortPages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetShortPages(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetShortPages(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }

    create(page: Page): Observable<string> {
        let url_ = this.baseUrl + "/api/pages";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(page);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreate(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreate(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    update(id: string | null, page: Page): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/pages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(page);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdate(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdate(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdate(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/pages/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    checkExist(name: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/pages/check-exist/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    submitCommand(pageId: string | null, pageSubmittedButtonModel: PageSubmittedButtonModel): Observable<ExecuteDynamicResultModel> {
        let url_ = this.baseUrl + "/api/pages/{pageId}/submit";
        if (pageId === undefined || pageId === null)
            throw new Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageSubmittedButtonModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSubmitCommand(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSubmitCommand(<any>response_);
                } catch (e) {
                    return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processSubmitCommand(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExecuteDynamicResultModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExecuteDynamicResultModel>(<any>null);
    }

    fetchControlDatasource(pageId: string | null, model: PageSelectionDatasourceModel): Observable<ExecuteDynamicResultModel> {
        let url_ = this.baseUrl + "/api/pages/{pageId}/fetch-control-datasource";
        if (pageId === undefined || pageId === null)
            throw new Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processFetchControlDatasource(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processFetchControlDatasource(<any>response_);
                } catch (e) {
                    return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processFetchControlDatasource(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExecuteDynamicResultModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExecuteDynamicResultModel>(<any>null);
    }

    executeTriggeredEvent(pageId: string | null, model: PageTriggeringEventModel): Observable<ExecuteDynamicResultModel> {
        let url_ = this.baseUrl + "/api/pages/{pageId}/trigger-control-event";
        if (pageId === undefined || pageId === null)
            throw new Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteTriggeredEvent(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteTriggeredEvent(<any>response_);
                } catch (e) {
                    return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExecuteTriggeredEvent(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExecuteDynamicResultModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExecuteDynamicResultModel>(<any>null);
    }

    executeAsyncValidator(pageId: string | null, validatorModel: PageAsyncValidatorModel): Observable<ExecuteDynamicResultModel> {
        let url_ = this.baseUrl + "/api/pages/{pageId}/async-validator";
        if (pageId === undefined || pageId === null)
            throw new Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(validatorModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processExecuteAsyncValidator(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processExecuteAsyncValidator(<any>response_);
                } catch (e) {
                    return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processExecuteAsyncValidator(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExecuteDynamicResultModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExecuteDynamicResultModel>(<any>null);
    }

    getDatasourceForPage(pageId: string | null, pageRequestDatasourceModel: PageRequestDatasourceModel): Observable<ExecuteDynamicResultModel> {
        let url_ = this.baseUrl + "/api/pages/{pageId}/fetch-datasource";
        if (pageId === undefined || pageId === null)
            throw new Error("The parameter 'pageId' must be defined.");
        url_ = url_.replace("{pageId}", encodeURIComponent("" + pageId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(pageRequestDatasourceModel);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetDatasourceForPage(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetDatasourceForPage(<any>response_);
                } catch (e) {
                    return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(e);
                }
            } else
                return <Observable<ExecuteDynamicResultModel>><any>_observableThrow(response_);
        }));
    }

    protected processGetDatasourceForPage(response: HttpResponseBase): Observable<ExecuteDynamicResultModel> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ExecuteDynamicResultModel>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ExecuteDynamicResultModel>(<any>null);
    }

    clone(model: CloneModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/pages/clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClone(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClone(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    generateLanguages(id: string | null): Observable<LanguageKey[]> {
        let url_ = this.baseUrl + "/api/pages/{id}/languages";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGenerateLanguages(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGenerateLanguages(<any>response_);
                } catch (e) {
                    return <Observable<LanguageKey[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<LanguageKey[]>><any>_observableThrow(response_);
        }));
    }

    protected processGenerateLanguages(response: HttpResponseBase): Observable<LanguageKey[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <LanguageKey[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<LanguageKey[]>(<any>null);
    }
}

export interface IStandardComponentClient {
    getOne(id: string | null): Observable<StandardComponent>;
    updateOne(id: string | null, standardComponent: StandardComponent): Observable<FileResponse>;
    delete(id: string | null): Observable<FileResponse>;
    getOneForRender(id: string | null): Observable<StandardComponent>;
    getSortStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
    getSortArrayStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
    getSortTreeStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]>;
    createOne(standardComponent: StandardComponent): Observable<string>;
    createBulk(standardComponents: StandardComponent[]): Observable<FileResponse>;
    getManys(ids: string | null | undefined): Observable<StandardComponent[]>;
    getArrayStandards(ids: string | null | undefined): Observable<StandardComponent[]>;
    getTreeStandards(ids: string | null | undefined): Observable<StandardComponent[]>;
    checkExist(name: string | null): Observable<boolean>;
    clone(model: CloneModel): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class StandardComponentClient implements IStandardComponentClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    getOne(id: string | null): Observable<StandardComponent> {
        let url_ = this.baseUrl + "/api/standards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOne(<any>response_);
                } catch (e) {
                    return <Observable<StandardComponent>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardComponent>><any>_observableThrow(response_);
        }));
    }

    protected processGetOne(response: HttpResponseBase): Observable<StandardComponent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StandardComponent>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardComponent>(<any>null);
    }

    updateOne(id: string | null, standardComponent: StandardComponent): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/standards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(standardComponent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateOne(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processUpdateOne(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    delete(id: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/standards/{id}";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDelete(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDelete(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processDelete(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getOneForRender(id: string | null): Observable<StandardComponent> {
        let url_ = this.baseUrl + "/api/standards/{id}/render";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetOneForRender(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetOneForRender(<any>response_);
                } catch (e) {
                    return <Observable<StandardComponent>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardComponent>><any>_observableThrow(response_);
        }));
    }

    protected processGetOneForRender(response: HttpResponseBase): Observable<StandardComponent> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StandardComponent>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardComponent>(<any>null);
    }

    getSortStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/standards/short-standards?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortStandards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortStandards(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortStandards(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }

    getSortArrayStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/standards/short-array-standards?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortArrayStandards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortArrayStandards(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortArrayStandards(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }

    getSortTreeStandards(keyWord: string | null | undefined): Observable<ShortEntityModel[]> {
        let url_ = this.baseUrl + "/api/standards/short-tree-standards?";
        if (keyWord !== undefined && keyWord !== null)
            url_ += "keyWord=" + encodeURIComponent("" + keyWord) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetSortTreeStandards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetSortTreeStandards(<any>response_);
                } catch (e) {
                    return <Observable<ShortEntityModel[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<ShortEntityModel[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetSortTreeStandards(response: HttpResponseBase): Observable<ShortEntityModel[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <ShortEntityModel[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<ShortEntityModel[]>(<any>null);
    }

    createOne(standardComponent: StandardComponent): Observable<string> {
        let url_ = this.baseUrl + "/api/standards";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(standardComponent);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateOne(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateOne(<any>response_);
                } catch (e) {
                    return <Observable<string>><any>_observableThrow(e);
                }
            } else
                return <Observable<string>><any>_observableThrow(response_);
        }));
    }

    protected processCreateOne(response: HttpResponseBase): Observable<string> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <string>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<string>(<any>null);
    }

    createBulk(standardComponents: StandardComponent[]): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/standards/bulk";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(standardComponents);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCreateBulk(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCreateBulk(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processCreateBulk(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }

    getManys(ids: string | null | undefined): Observable<StandardComponent[]> {
        let url_ = this.baseUrl + "/api/standards/bulk?";
        if (ids !== undefined && ids !== null)
            url_ += "ids=" + encodeURIComponent("" + ids) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetManys(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetManys(<any>response_);
                } catch (e) {
                    return <Observable<StandardComponent[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardComponent[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetManys(response: HttpResponseBase): Observable<StandardComponent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StandardComponent[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardComponent[]>(<any>null);
    }

    getArrayStandards(ids: string | null | undefined): Observable<StandardComponent[]> {
        let url_ = this.baseUrl + "/api/standards/bulk-array?";
        if (ids !== undefined && ids !== null)
            url_ += "ids=" + encodeURIComponent("" + ids) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetArrayStandards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetArrayStandards(<any>response_);
                } catch (e) {
                    return <Observable<StandardComponent[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardComponent[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetArrayStandards(response: HttpResponseBase): Observable<StandardComponent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StandardComponent[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardComponent[]>(<any>null);
    }

    getTreeStandards(ids: string | null | undefined): Observable<StandardComponent[]> {
        let url_ = this.baseUrl + "/api/standards/bulk-tree?";
        if (ids !== undefined && ids !== null)
            url_ += "ids=" + encodeURIComponent("" + ids) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetTreeStandards(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetTreeStandards(<any>response_);
                } catch (e) {
                    return <Observable<StandardComponent[]>><any>_observableThrow(e);
                }
            } else
                return <Observable<StandardComponent[]>><any>_observableThrow(response_);
        }));
    }

    protected processGetTreeStandards(response: HttpResponseBase): Observable<StandardComponent[]> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <StandardComponent[]>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<StandardComponent[]>(<any>null);
    }

    checkExist(name: string | null): Observable<boolean> {
        let url_ = this.baseUrl + "/api/standards/check-exist/{name}";
        if (name === undefined || name === null)
            throw new Error("The parameter 'name' must be defined.");
        url_ = url_.replace("{name}", encodeURIComponent("" + name));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCheckExist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCheckExist(<any>response_);
                } catch (e) {
                    return <Observable<boolean>><any>_observableThrow(e);
                }
            } else
                return <Observable<boolean>><any>_observableThrow(response_);
        }));
    }

    protected processCheckExist(response: HttpResponseBase): Observable<boolean> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            let result200: any = null;
            result200 = _responseText === "" ? null : <boolean>JSON.parse(_responseText, this.jsonParseReviver);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<boolean>(<any>null);
    }

    clone(model: CloneModel): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/standards/clone";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(model);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClone(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClone(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processClone(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface IConfigurationClient {
    get(serviceName: string | null, version: string | null): Observable<FileResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class ConfigurationClient implements IConfigurationClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(PORTAL_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl !== undefined && baseUrl !== null ? baseUrl : "http://localhost:5101";
    }

    get(serviceName: string | null, version: string | null): Observable<FileResponse> {
        let url_ = this.baseUrl + "/api/configurations/{serviceName}/{version}";
        if (serviceName === undefined || serviceName === null)
            throw new Error("The parameter 'serviceName' must be defined.");
        url_ = url_.replace("{serviceName}", encodeURIComponent("" + serviceName));
        if (version === undefined || version === null)
            throw new Error("The parameter 'version' must be defined.");
        url_ = url_.replace("{version}", encodeURIComponent("" + version));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGet(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGet(<any>response_);
                } catch (e) {
                    return <Observable<FileResponse>><any>_observableThrow(e);
                }
            } else
                return <Observable<FileResponse>><any>_observableThrow(response_);
        }));
    }

    protected processGet(response: HttpResponseBase): Observable<FileResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (<any>response).error instanceof Blob ? (<any>response).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            const fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
            const fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            return _observableOf({ fileName: fileName, data: <any>responseBlob, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap(_responseText => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf<FileResponse>(<any>null);
    }
}

export interface OnlineUser {
    userName?: string | undefined;
    fullName?: string | undefined;
    avatar?: string | undefined;
    shortName?: string | undefined;
    hasAvatar?: boolean;
    isOnline?: boolean;
    numberOfDevices?: number;
}

export interface Entity {
    id?: string | undefined;
}

export interface BackupableEntity extends Entity {
    name?: string | undefined;
    displayName?: string | undefined;
    timeSpan?: number;
}

export interface App extends BackupableEntity {
    logo?: string | undefined;
    defaultUrl?: string | undefined;
    author?: string | undefined;
    currentVersionNumber?: string | undefined;
    createdDate?: Date;
    modifiedDate?: Date;
    menus?: Menu[] | undefined;
    menuProfiles?: MenuProfile[] | undefined;
}

export interface Menu {
    id?: string | undefined;
    displayName?: string | undefined;
    icon?: string | undefined;
    url?: string | undefined;
    order?: number;
    parentId?: string | undefined;
    menuPath?: string | undefined;
    hide?: boolean;
    subMenus?: Menu[] | undefined;
}

export interface MenuProfile {
    role?: string | undefined;
    menuIds?: string[] | undefined;
}

export interface ShortEntityModel {
    id?: string | undefined;
    displayName?: string | undefined;
    appId?: string | undefined;
}

export interface AvailableUrl {
    url?: string | undefined;
    name?: string | undefined;
    pageId?: string | undefined;
}

export interface CloneModel {
    cloneId?: string | undefined;
    cloneName?: string | undefined;
}

export interface PackageResponseModel {
    downloadableUrl?: string | undefined;
}

export interface PackageRequestModel {
    description: string;
    creator: string;
    appId: string;
}

export interface UnpackResponseModel {
    uploadFileId?: string | undefined;
    description?: string | undefined;
    creator?: string | undefined;
    packagedDate?: Date;
    app?: App | undefined;
    standards?: ComponentInstallState[] | undefined;
    dynamicLists?: ComponentInstallState[] | undefined;
    charts?: ComponentInstallState[] | undefined;
    pages?: ComponentInstallState[] | undefined;
    locales?: ComponentInstallState[] | undefined;
    totalStandards?: number;
    totalCharts?: number;
    totalDynamicLists?: number;
    totalPages?: number;
    totalLocales?: number;
    isExistedId?: boolean;
    isExistedName?: boolean;
}

export interface ComponentInstallState {
    name?: string | undefined;
    isExisted?: boolean;
}

export interface InstallRequestModel {
    uploadFileId?: string | undefined;
    installWay?: InstallWay;
}

export enum InstallWay {
    Merge = 0,
    Wipe = 1,
}

export interface PreviewPackageModel {
    app?: App | undefined;
    standards?: string[] | undefined;
    charts?: string[] | undefined;
    dynamicLists?: string[] | undefined;
    pages?: string[] | undefined;
    locales?: string[] | undefined;
}

export interface Backup extends Entity {
    name?: string | undefined;
    description?: string | undefined;
    creator?: string | undefined;
    fileId?: string | undefined;
    downloadableUrl?: string | undefined;
    backupElements?: BackupElements | undefined;
    encryptShalt?: string | undefined;
    createdDate?: Date;
}

export interface BackupElements {
    apps?: string[] | undefined;
    databases?: string[] | undefined;
    standards?: string[] | undefined;
    tree?: string[] | undefined;
    array?: string[] | undefined;
    charts?: string[] | undefined;
    dynamicLists?: string[] | undefined;
    pages?: string[] | undefined;
    compositeControls?: string[] | undefined;
}

export interface UploadBackupResponseModel {
    id?: string | undefined;
    name?: string | undefined;
    description?: string | undefined;
    creator?: string | undefined;
    createdDate?: Date;
    totalObjects?: number;
    isFileValid?: boolean;
}

export interface BackupResponseModel {
    downloadableUrl?: string | undefined;
}

export interface BackupRequestModel {
    apps?: string[] | undefined;
    databases?: string[] | undefined;
    standards?: string[] | undefined;
    tree?: string[] | undefined;
    array?: string[] | undefined;
    dynamicLists?: string[] | undefined;
    charts?: string[] | undefined;
    pages?: string[] | undefined;
    compositeControls?: string[] | undefined;
    name?: string | undefined;
    description?: string | undefined;
    creator?: string | undefined;
    encryptKey?: string | undefined;
}

export interface PreviewRestoreModel {
    apps?: ComparisonResult[] | undefined;
    standards?: ComparisonResult[] | undefined;
    tree?: ComparisonResult[] | undefined;
    array?: ComparisonResult[] | undefined;
    databases?: ComparisonResult[] | undefined;
    charts?: ComparisonResult[] | undefined;
    dynamicLists?: ComparisonResult[] | undefined;
    pages?: ComparisonResult[] | undefined;
    compositeControls?: ComparisonResult[] | undefined;
    totalObjects?: number;
    totalChangedObjects?: number;
    totalUnchangedObjects?: number;
    totalNewObjects?: number;
}

export interface ComparisonResult {
    result?: ComparisonEntity | undefined;
    isUnchanged?: boolean;
    isTotallyNew?: boolean;
}

export interface ComparisonEntity {
    properties?: ComparisonProperty[] | undefined;
}

export interface ComparisonProperty {
    name?: string | undefined;
    sourceValue?: string | undefined;
    targetValue?: string | undefined;
    comparedState?: ComparedState;
}

export enum ComparedState {
    New = 0,
    Unchanged = 1,
    Changed = 2,
    Deleted = 3,
}

export interface RestoreRequestModel {
    id?: string | undefined;
    requestor?: string | undefined;
}

export interface GenerateCodeRequestModel {
    apps?: string[] | undefined;
    databases?: string[] | undefined;
    standards?: string[] | undefined;
    tree?: string[] | undefined;
    array?: string[] | undefined;
    dynamicLists?: string[] | undefined;
    charts?: string[] | undefined;
    pages?: string[] | undefined;
    compositeControls?: string[] | undefined;
    fileName?: string | undefined;
    versionNumber?: string | undefined;
}

export interface Component extends BackupableEntity {
    datasourceName?: string | undefined;
    appId?: string | undefined;
    options?: ShellOption[] | undefined;
    layoutType?: PageSectionLayoutType;
    allowOverrideOptions?: boolean;
    allowPassingDatasource?: boolean;
}

export interface Chart extends Component {
    definitions?: ChartDefinitions | undefined;
    databaseOptions?: SharedDatabaseOptions | undefined;
    chartFilters?: ChartFilter[] | undefined;
}

export interface ChartDefinitions {
    chartTitle?: string | undefined;
    chartType?: ChartType;
    mappingProjection?: string | undefined;
}

export enum ChartType {
    VerticalBarChart = 0,
    HorizontalBarChart = 1,
    GroupedVerticalBarChart = 2,
    GroupedHorizontalBarChart = 3,
    PieChart = 4,
    AdvancedPieChart = 5,
    PieGrid = 6,
    LineChart = 7,
    AreaChart = 8,
    Gauge = 9,
    NumberCard = 10,
}

export interface SharedDatabaseOptions {
    databaseConnectionId?: string | undefined;
    entityName?: string | undefined;
    query?: string | undefined;
}

export interface ChartFilter {
    name?: string | undefined;
    displayName?: string | undefined;
    type?: FilterType;
    datasourceOptions?: DatasourceOptions | undefined;
    rangeValue?: string | undefined;
    defaultValue?: string | undefined;
    allowDefaultValue?: boolean;
    isMultiple?: boolean;
    isHidden?: boolean;
}

export enum FilterType {
    None = 0,
    Checkbox = 1,
    Select = 2,
    NumberPicker = 3,
    DatePicker = 4,
    MonthYearPicker = 5,
}

export interface DatasourceOptions {
    type?: DatasourceControlType;
    datasourceStaticOptions?: DatasourceStaticOptions | undefined;
    databaseOptions?: SharedDatabaseOptions | undefined;
    httpServiceOptions?: HttpServiceOptions | undefined;
    triggeredEvents?: string | undefined;
}

export enum DatasourceControlType {
    StaticResource = 0,
    Database = 1,
    WebService = 2,
}

export interface DatasourceStaticOptions {
    jsonResource?: string | undefined;
}

export interface HttpServiceOptions {
    httpServiceUrl?: string | undefined;
    httpMethod?: string | undefined;
    httpSuccessCode?: string | undefined;
    jsonBody?: string | undefined;
    outputProjection?: string | undefined;
}

export interface ShellOption {
    key?: string | undefined;
    value?: string | undefined;
    description?: string | undefined;
}

export enum PageSectionLayoutType {
    OneColumn = 0,
    TwoColumns = 1,
    ThreeColumns = 2,
    FourColumns = 3,
    SixColumns = 4,
}

export interface ExtractionChartFilter {
    filters?: ChartFilter[] | undefined;
}

export interface ExtractingChartQueryModel {
    parameters?: FilledParameterModel[] | undefined;
    query?: string | undefined;
    databaseId?: string | undefined;
}

export interface FilledParameterModel {
    name?: string | undefined;
    value?: string | undefined;
}

export interface ExecutionChartResponseModel {
    isSuccess?: boolean;
    result?: any | undefined;
    error?: string | undefined;
}

export interface ExecutionChartRequestModel {
    chartId?: string | undefined;
    isRealTime?: boolean;
    lastRealTimeComparedDate?: Date | undefined;
    realTimeField?: string | undefined;
    chartParameterValues?: ChartParameterValue[] | undefined;
    chartFilterValues?: ChartFilterValue[] | undefined;
}

export interface ChartParameterValue {
    name?: string | undefined;
    value?: string | undefined;
    replaceDQuotes?: boolean;
}

export interface ChartFilterValue {
    name?: string | undefined;
    filterType?: FilterType;
    isMultiple?: boolean;
    value?: string | undefined;
}

export interface CompositeControl extends Entity {
    name?: string | undefined;
    displayName?: string | undefined;
    appId?: string | undefined;
    controls?: PageControl[] | undefined;
}

export interface PageControl {
    id?: string | undefined;
    name?: string | undefined;
    datasourceOptions?: DatasourceOptions | undefined;
    isActive?: boolean;
    order?: number;
    type?: ControlType;
    compositeControlId?: string | undefined;
    validators?: PageControlValidator[] | undefined;
    asyncValidators?: PageControlAsyncValidator[] | undefined;
    options?: ShellOption[] | undefined;
    pageControlEvents?: PageControlEvent[] | undefined;
}

export enum ControlType {
    LineBreaker = 0,
    Label = 1,
    Textbox = 2,
    Textarea = 3,
    Number = 4,
    Email = 5,
    Password = 6,
    DateTime = 7,
    Checkbox = 8,
    Slide = 9,
    Radio = 10,
    Select = 11,
    AutoComplete = 12,
    RichTextEditor = 13,
    Uploader = 14,
    MultiUploader = 15,
    IconPicker = 16,
    MarkdownEditor = 17,
    Composite = 18,
}

export interface PageControlValidator {
    validatorType?: ValidatorType;
    isActive?: boolean;
    validatorOption?: string | undefined;
    validatorMessage?: string | undefined;
}

export enum ValidatorType {
    Required = 0,
    MinLength = 1,
    MaxLength = 2,
    NumberRange = 3,
    Number = 4,
    MinDate = 5,
    MaxDate = 6,
    DateTime = 7,
    Equal = 8,
    EqualTo = 9,
    Regex = 10,
    Email = 11,
    Json = 12,
    FileExtensions = 13,
    FileMaximumSize = 14,
    FileMaximumFiles = 15,
}

export interface PageControlAsyncValidator {
    validatorName?: string | undefined;
    isActive?: boolean;
    validatorMessage?: string | undefined;
    asyncValidatorOptions?: ControlAsyncValidatorOptions | undefined;
}

export interface ControlAsyncValidatorOptions {
    validatorType?: AsyncValidatorType;
    evaluatedExpression?: string | undefined;
    databaseOptions?: SharedDatabaseOptions | undefined;
    httpServiceOptions?: HttpServiceOptions | undefined;
}

export enum AsyncValidatorType {
    DatabaseValidator = 0,
    HttpValidator = 1,
}

export interface PageControlEvent {
    eventName?: string | undefined;
    eventActionType?: EventActionType;
    eventHttpServiceOptions?: EventHttpServiceOptions | undefined;
    eventDatabaseOptions?: EventDatabaseOptions | undefined;
    triggerEventOptions?: TriggerEventOptions | undefined;
}

export enum EventActionType {
    TriggerEvent = 0,
    QueryDatabase = 1,
    WebService = 2,
}

export interface EventHttpServiceOptions extends HttpServiceOptions {
    boundData?: string[] | undefined;
}

export interface EventDatabaseOptions extends SharedDatabaseOptions {
    outputProjection?: string | undefined;
    boundData?: string[] | undefined;
}

export interface TriggerEventOptions {
    eventsList?: string[] | undefined;
}

export interface DatabaseConnection extends BackupableEntity {
    connectionString?: string | undefined;
    dataSource?: string | undefined;
    databaseConnectionType?: string | undefined;
}

export interface ExecuteDynamicResultModel {
    result?: any | undefined;
    isSuccess?: boolean;
    error?: string | undefined;
}

export interface ExtractingSchemaQueryModel {
    columnFields?: ColumnField[] | undefined;
}

export interface ColumnField {
    name?: string | undefined;
    displayName?: string | undefined;
    fieldType?: string | undefined;
}

export interface ExtractionDatabaseRequestModel {
    content?: any | undefined;
    parameters?: ExecuteParamModel[] | undefined;
}

export interface ExecuteParamModel {
    name?: string | undefined;
    replaceValue?: string | undefined;
    removeQuotes?: boolean;
}

export interface DynamicList extends Component {
    listDatasource?: DynamicListDatasource | undefined;
    paramsList?: ParamsList | undefined;
    filtersList?: FiltersList | undefined;
    columnsList?: ColumnsList | undefined;
    commandsList?: CommandsList | undefined;
}

export interface DynamicListDatasource {
    sourceType?: DynamicListSourceType;
    databaseConnectionOptions?: SharedDatabaseOptions | undefined;
    httpServiceOptions?: HttpServiceOptions | undefined;
}

export enum DynamicListSourceType {
    Database = 0,
    HttpService = 1,
}

export interface ParamsList {
    parameters?: Parameter[] | undefined;
}

export interface Parameter {
    name?: string | undefined;
}

export interface FiltersList {
    filterFields?: FilterField[] | undefined;
}

export interface FilterField {
    name?: string | undefined;
    displayName?: string | undefined;
    fieldValueType?: FieldValueType;
    isHidden?: boolean;
    allowTextSearch?: boolean;
    allowInAdvancedMode?: boolean;
}

export enum FieldValueType {
    Text = 0,
    Select = 1,
    Checkbox = 2,
    Slide = 3,
    DatePicker = 4,
    Number = 5,
}

export interface ColumnsList {
    columnDefs?: ColumnDef[] | undefined;
}

export interface ColumnDef {
    id?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    displayFormat?: string | undefined;
    htmlFunction?: string | undefined;
    displayFormatAsHtml?: boolean;
    allowSort?: boolean;
    searchOptions?: SearchOptions | undefined;
    datasourceOptions?: DynamicListDatasourceOptions | undefined;
    isHidden?: boolean;
    order?: number;
}

export interface SearchOptions {
    fieldValueType?: FieldValueType;
    allowTextSearch?: boolean;
    allowInAdvancedMode?: boolean;
}

export interface DynamicListDatasourceOptions extends DatasourceOptions {
    outputMapProjection?: string | undefined;
}

export interface CommandsList {
    commandButtonsInList?: CommandButtonInList[] | undefined;
}

export interface CommandButtonInList {
    id?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    commandPositionType?: CommandPositionType;
    actionCommandOptions?: ActionCommandOptions | undefined;
    allowRefreshList?: boolean;
    order?: number;
}

export enum CommandPositionType {
    InList = 0,
    OutList = 1,
}

export interface ActionCommandOptions {
    isEnable?: boolean;
    actionType?: ActionType;
    redirectOptions?: RedirectOptions | undefined;
    httpServiceOptions?: HttpServiceOptions | undefined;
    dbExecutionChains?: DatabaseExecutionChains | undefined;
    workflowOptions?: WorkflowOptions | undefined;
    notificationOptions?: NotificationOptions | undefined;
    confirmationOptions?: ConfirmationOptions | undefined;
}

export enum ActionType {
    ExecuteDatabase = 0,
    CallHttpService = 1,
    CallWorkflow = 2,
    Redirect = 3,
}

export interface RedirectOptions {
    redirectUrl?: string | undefined;
    isSameDomain?: boolean;
}

export interface DatabaseExecutionChains {
    steps?: DatabaseExecutionStep[] | undefined;
}

export interface DatabaseExecutionStep {
    dataLoopKey?: string | undefined;
    databaseConnectionId?: string | undefined;
    executeCommand?: string | undefined;
}

export interface WorkflowOptions {
    workflowId?: string | undefined;
    mapWorkflowInputs?: MapWorkflowInput[] | undefined;
}

export interface MapWorkflowInput {
    bindName?: string | undefined;
    bindValue?: string | undefined;
}

export interface NotificationOptions {
    completeMessage?: string | undefined;
    failedMessage?: string | undefined;
}

export interface ConfirmationOptions {
    isEnable?: boolean;
    confirmationText?: string | undefined;
}

export interface DynamicListResponseDataModel {
    data?: any | undefined;
    totalItems?: number;
}

export interface DynamicListFetchDataModel {
    dynamicListId?: string | undefined;
    textSearch?: string | undefined;
    filledParameterOptions?: FilledParameterOptions | undefined;
    filterGroupOptions?: FilterGroupOptions | undefined;
    paginationOptions?: PaginationOptions | undefined;
    sortOptions?: SortOptions | undefined;
}

export interface FilledParameterOptions {
    filledParameters?: FilledParameter[] | undefined;
}

export interface FilledParameter {
    name?: string | undefined;
    value?: string | undefined;
}

export interface FilterGroupOptions {
    filterGroups?: FilterGroup[] | undefined;
}

export interface FilterGroup {
    filterOptions?: FilterOption[] | undefined;
    filterChainOperator?: FilterChainOperator;
}

export interface FilterOption {
    fieldName?: string | undefined;
    filterOperator?: FilterOperator;
    fieldValue?: any | undefined;
    filterValueType?: FieldValueType;
    filterChainOperator?: FilterChainOperator;
}

export enum FilterOperator {
    Equal = 0,
    Contains = 1,
    Lesser = 2,
    Greater = 3,
    Less = 4,
    Great = 5,
}

export enum FilterChainOperator {
    None = 0,
    And = 1,
    Or = 2,
}

export interface PaginationOptions {
    pageNumber?: number;
    pageSize?: number;
    needTotalItems?: boolean;
}

export interface SortOptions {
    sortableFields?: SortableField[] | undefined;
}

export interface SortableField {
    fieldName?: string | undefined;
    sortType?: SortType;
}

export enum SortType {
    Asc = 0,
    Desc = 1,
}

export interface PopulateQueryModel {
    columnFields?: ColumnField[] | undefined;
}

export interface ExtractingQueryModel {
    parameters?: FilledParameterModel2[] | undefined;
    query?: string | undefined;
    databaseId?: string | undefined;
}

export interface FilledParameterModel2 {
    name?: string | undefined;
    value?: string | undefined;
}

export interface EntitySchema extends Entity {
    name?: string | undefined;
    displayName?: string | undefined;
    timeSpan?: number;
    databaseId?: string | undefined;
    appId?: string | undefined;
    entityFields?: EntityField[] | undefined;
}

export interface EntityField {
    name?: string | undefined;
    displayName?: string | undefined;
    fieldType?: string | undefined;
}

export interface FlushDatabaseModel {
    databaseId?: string | undefined;
    keptSameName?: boolean;
}

export interface ResponseUploadFile {
    fileId?: string | undefined;
    downloadableUrl?: string | undefined;
}

export interface File extends Entity {
    name?: string | undefined;
    uploader?: string | undefined;
    downloadableUrl?: string | undefined;
    identifierOptions?: string | undefined;
    mimeType?: string | undefined;
    fileSize?: number;
    allowCompress?: boolean;
    fileStorageType?: FileStorageType;
    dateUploaded?: Date;
}

export enum FileStorageType {
    Disk = 0,
    Database = 1,
}

export interface Localization extends Entity {
    localizationContents?: LocalizationContent[] | undefined;
    localeId?: string | undefined;
    appId?: string | undefined;
}

export interface LocalizationContent extends Entity {
    key?: string | undefined;
    text?: string | undefined;
    localizationId?: string | undefined;
    localization?: Localization | undefined;
}

export interface LanguageKey {
    key?: string | undefined;
    value?: string | undefined;
}

export interface ShortPageModel {
    id?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    urlPath?: string | undefined;
}

export interface ShortPortalClaimModel {
    pageName?: string | undefined;
    pageDisplayName?: string | undefined;
    claims?: PortalClaim[] | undefined;
}

export interface PortalClaim {
    name?: string | undefined;
    displayName?: string | undefined;
    claimValueType?: ClaimValueType;
}

export enum ClaimValueType {
    Boolean = 0,
    String = 1,
    Number = 2,
    Array = 3,
}

export interface Page extends BackupableEntity {
    urlPath?: string | undefined;
    appId?: string | undefined;
    shellOptions?: ShellOption[] | undefined;
    claims?: PortalClaim[] | undefined;
    builder?: PageBuilder | undefined;
    pageDatasources?: PageDatasource[] | undefined;
    events?: PageEvent[] | undefined;
    commands?: PageButton[] | undefined;
}

export interface PageBuilder {
    sections?: PageSection[] | undefined;
}

export interface PageSection {
    id?: string | undefined;
    name?: string | undefined;
    displayName?: string | undefined;
    constructionType?: SectionContructionType;
    overrideOptions?: ShellOption[] | undefined;
    sectionDatasource?: SectionDatasource | undefined;
    componentId?: string | undefined;
    hidden?: string | undefined;
    rendered?: string | undefined;
    order?: number;
}

export enum SectionContructionType {
    Standard = 0,
    Array = 1,
    DynamicList = 2,
    Chart = 3,
    Tree = 4,
}

export interface SectionDatasource {
    datasourceBindName?: string | undefined;
    dataStoreName?: string | undefined;
}

export interface PageDatasource {
    id?: string | undefined;
    name?: string | undefined;
    triggerCondition?: string | undefined;
    isActive?: boolean;
    options?: DatasourceOptions | undefined;
}

export interface PageEvent {
    eventName?: string | undefined;
    eventActionType?: EventActionType;
    httpServiceOptions?: EventHttpServiceOptions | undefined;
    triggerEventOptions?: TriggerEventOptions | undefined;
}

export interface PageButton {
    id?: string | undefined;
    name?: string | undefined;
    icon?: string | undefined;
    color?: string | undefined;
    isRequiredValidation?: boolean;
    allowHidden?: string | undefined;
    placeSectionId?: string | undefined;
    buttonOptions?: ButtonOptions | undefined;
}

export interface ButtonOptions {
    actionCommandOptions?: ActionCommandOptions | undefined;
    routeOptions?: RouteOptions | undefined;
}

export interface RouteOptions {
    routes?: Route[] | undefined;
    isEnable?: boolean;
}

export interface Route {
    redirectUrl?: string | undefined;
    isSameDomain?: boolean;
    condition?: string | undefined;
}

export interface PageSubmittedButtonModel {
    buttonName?: string | undefined;
    parameters?: PageParameterModel[] | undefined;
    loopDatas?: LoopDataModel[] | undefined;
}

export interface PageParameterModel {
    name?: string | undefined;
    replaceValue?: string | undefined;
    removeQuotes?: boolean;
}

export interface LoopDataModel {
    name?: string | undefined;
    parameters?: PageParameterModel[][] | undefined;
}

export interface PageSelectionDatasourceModel {
    sectionName?: string | undefined;
    controlName?: string | undefined;
    compositeControlId?: string | undefined;
    isChildCompositeControl?: boolean;
    parameters?: PageParameterModel[] | undefined;
}

export interface PageTriggeringEventModel {
    sectionName?: string | undefined;
    controlName?: string | undefined;
    eventName?: string | undefined;
    parameters?: PageParameterModel[] | undefined;
}

export interface PageAsyncValidatorModel {
    sectionName?: string | undefined;
    controlName?: string | undefined;
    asyncName?: string | undefined;
    parameters?: PageParameterModel[] | undefined;
}

export interface PageRequestDatasourceModel {
    datasourceId?: string | undefined;
    parameters?: PageParameterModel[] | undefined;
}

export interface StandardComponent extends Component {
    type?: StandardType;
    controls?: PageControl[] | undefined;
}

export enum StandardType {
    Standard = 0,
    Array = 1,
    Tree = 2,
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class SwaggerException extends Error {
    message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isSwaggerException = true;

    static isSwaggerException(obj: any): obj is SwaggerException {
        return obj.isSwaggerException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    return _observableThrow(new SwaggerException(message, status, response, headers, result));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((<any>event.target).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}